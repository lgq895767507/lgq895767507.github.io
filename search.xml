<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Context上下文简述]]></title>
    <url>%2F2019%2F08%2F15%2FContext%2F</url>
    <content type="text"><![CDATA[Context 抽象类,activity，service, application都是其子类因此一个应用程序中 Context 的数量等于 Activity 和 Service 的数量加1。 Context的主要功能为: 1)启动Activity2）启动和停止Service3）发送广播消息(Intent)4）注册广播消息(Intent)接收者5）可以访问APK中各种资源(如Resources和AssetManager等)6）可以访问Package的相关信息7）APK的各种权限管理 // 返回当前进程的单实例全局Application对象的Context,指向的是Contextpublic abstract Context getApplicationContext(); //返回由构造函数指定或setBaseContext()设置的上下文。getBaseContext() //getApplication()只能在Activity和Service里使用，指向的是Application对象getApplication() 很重要的一点，activity的context对象在activity销毁的时候，context也会跟着销毁,所以持有activity对象没有及时销毁可能造成内存泄漏。 Intent也要求指出上下文，如果是activity的上下文就会把启动的activity关联当前的activity，如果是application的context，那么启动就需要添加Intent.FLAG_ACTIVITY_NEW_TASK标志，否则会报错。相当于重新创建了一个新的栈。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android View的加载与绘制源码分析]]></title>
    <url>%2F2019%2F08%2F05%2FView%E7%9A%84%E5%8A%A0%E8%BD%BD%E4%B8%8E%E7%BB%98%E5%88%B6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[（一）Android View的加载源码分析 view是如果被加载到界面上的？创建一个普通的activity 123456789101112131415161718192021222324//1.MainActivity.javapublic class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //添加布局入口 setContentView(R.layout.activity_main); &#125;&#125;//2.Activity.javapublic void setContentView(@LayoutRes int layoutResID) &#123; getWindow().setContentView(layoutResID); initWindowDecorActionBar(); &#125;//getWindow()获取的window对象是mWindow，Window类是个抽象类，拥有唯一的实例android.view.PhoneWindow/* &lt;p&gt;The only existing implementation of this abstract class is android.view.PhoneWindow, which you should instantiate when needing a Window. */ public abstract class Window &#123; ... &#125; PhoneWindow.java文件 1234567891011121314151617181920212223242526272829303132//3.PhoneWindow.java//因此到PhoneWindow找到setContentView(int layoutResID)@Override public void setContentView(int layoutResID) &#123; // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window // decor, when theme attributes and the like are crystalized. Do not check the feature // before this happens. if (mContentParent == null) &#123; installDecor(); &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; mContentParent.removeAllViews(); &#125; if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID, getContext()); transitionTo(newScene); &#125; else &#123; mLayoutInflater.inflate(layoutResID, mContentParent); &#125; mContentParent.requestApplyInsets(); final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) &#123; cb.onContentChanged(); &#125; &#125;//4. installDecor(); //5. mLayoutInflater.inflate(layoutResID, mContentParent);//解析传进来的layoutResID和mContentParent， 实际上就是把传进来的mContentParent加载到mContentParent上，mContentParent是一个frameLayout 12345678910111213141516//4. installDecor();//4.1创建DevorView mDecor = generateDecor(); //4.2创建mContentParent mContentParent = generateLayout(mDecor); //4.2创建mContentParent//解析基础控件layoutResourceView in = mLayoutInflater.inflate(layoutResource, null);//DecorView添加基础控件indecor.addView(in, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));mContentRoot = (ViewGroup) in;//添加ID_ANDROID_CONTENT 并且直接返回contentParentViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT); 1234567891011121314151617181920212223242526272829303132// layoutResource是一个基础控件ViewGroup//xref: /frameworks/base/core/res/res/layout/screen_title.xml&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"23 android:orientation="vertical"24 android:fitsSystemWindows="true"&gt;25 &lt;!-- Popout bar for action modes --&gt;26 &lt;ViewStub android:id="@+id/action_mode_bar_stub"27 android:inflatedId="@+id/action_mode_bar"28 android:layout="@layout/action_mode_bar"29 android:layout_width="match_parent"30 android:layout_height="wrap_content"31 android:theme="?attr/actionBarTheme" /&gt;32 &lt;FrameLayout33 android:layout_width="match_parent" 34 android:layout_height="?android:attr/windowTitleSize"35 style="?android:attr/windowTitleBackgroundStyle"&gt;36 &lt;TextView android:id="@android:id/title" 37 style="?android:attr/windowTitleStyle"38 android:background="@null"39 android:fadingEdge="horizontal"40 android:gravity="center_vertical"41 android:layout_width="match_parent"42 android:layout_height="match_parent" /&gt;43 &lt;/FrameLayout&gt;44 &lt;FrameLayout android:id="@android:id/content"45 android:layout_width="match_parent" 46 android:layout_height="0dip"47 android:layout_weight="1"48 android:foregroundGravity="fill_horizontal|top"49 android:foreground="?android:attr/windowContentOverlay" /&gt;50&lt;/LinearLayout&gt; View就这样被加载到界面上了 总结：* 创建顶层布局容器DecorView * 在顶层布局中添加基础布局ViewGroup * 将contentView添加到基础布局容器的FrameLayout中(二) Android View绘制源码分析 view是如何绘制的？ ActivityThread.class 123456789101112131415public void handleMessage(Message msg) &#123; if (DEBUG_MESSAGES) Slog.v(TAG, "&gt;&gt;&gt; handling: " + codeToString(msg.what)); switch (msg.what) &#123; case LAUNCH_ACTIVITY: &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "activityStart"); final ActivityClientRecord r = (ActivityClientRecord) msg.obj; r.packageInfo = getPackageInfoNoCheck( r.activityInfo.applicationInfo, r.compatInfo); handleLaunchActivity(r, null); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); &#125; break; ...&#125; 2.handleLaunchActivity 3.handleResumeActivity 4.wm.addView(decor, l); 12345678910111213141516171819// 4.wm.addView(decor, l); ViewManager wm = a.getWindowManager(); -&gt; mWindowManager = mWindow.getWindowManager(); //mWindow唯一的实例是 PhoneWindow，因此 -&gt; mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this); //因此wm是WindowManagerImpl的实例,在addView中调用了mGlobal.addView（） -&gt; mGlobal.addView(view, params, mDisplay, mParentWindow); //ViewRootImpl关联view, params, panelParentView,root是ViewRootImpl实例化对象 -&gt; root.setView(view, wparams, panelParentView); -&gt; requestLayout() -&gt; checkThread(); -&gt; scheduleTraversals(); -&gt; TraversalRunnable&#123;&#125; -&gt; doTraversal(); -&gt; performTraversals(); -&gt; performMeasure(childWidthMeasureSpec,childHeightMeasureSpec); //1890 测量 -&gt; performLayout(lp, desiredWindowWidth, desiredWindowHeight); //1931 布局 -&gt; performDraw(); // 2067 绘制 view的绘制流程就是以上这些步骤，现在具体来看下performMeasure(),performLayout(),performDraw()这三步关键的步骤。 测量：performMeasure() 先引入一个概念MeasureSpec，view的测量规格，是一个32位的二进制整数类型。view的测量按照一定的规则，以下是MeasureSpec的一些规则： 123456789101112131415161718192021222324//MeasureSpec.java public static int makeMeasureSpec(int size, int mode) &#123; if (sUseBrokenMakeMeasureSpec) &#123; return size + mode; &#125; else &#123; return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK); &#125; &#125;UNSPECIFIED: 00 0000 0000 0000 0000 0000 0000 0000 00-&gt; 父容器不对view做任何限制，系统内部使用 EXACTLY: 01 0000 0000 0000 0000 0000 0000 0000 00-&gt; 父容器检测view的大小，view的大小就是SpecSize ，对应子控件的 LayoutParams.match_parent / 固定大小 AT_MOST: 10 0000 0000 0000 0000 0000 0000 0000 00-&gt; 父容器指定一个可用大小，view不能超过这个值， LayoutParams.wrap_contentMODE_MASK = 11 0000 0000 0000 0000 0000 0000 0000 00 ~MODE_MASK = 00 1111 1111 1111 1111 1111 1111 1111 11 size &amp; ~MODE_MASK = 00 后三十位 model &amp; MODE_MASK = 前两位 0000 0000 0000 0000 0000 0000 0000 00(size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK); == model(前两位) size(后三十位) 继续回到 ViewRootImpl 的1890行 performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); 1234567891011121314151617-&gt; performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);-&gt; mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);-&gt; onMeasure(widthMeasureSpec, heightMeasureSpec);-&gt; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)); //保存自身的宽和高-&gt; setMeasuredDimensionRaw(measuredWidth, measuredHeight);//此处即测量结束，赋值给宽高，并设置标记flagsprivate void setMeasuredDimensionRaw(int measuredWidth, int measuredHeight) &#123; mMeasuredWidth = measuredWidth; mMeasuredHeight = measuredHeight; mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET; &#125;//以上来看view的测量就结束了。但是view是如何测量的，就需要了解传进来的参数childWidthMeasureSpec，childHeightMeasureSpec是怎么得来的 int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width); //1854 ViewRootImpl.java 1234567891011121314151617//mWidth ： 窗口容器的宽度//lp.width: 顶层容器的宽度getRootMeasureSpec(mWidth, lp.width)// 因此 DecorView的MeasureSpec由窗口大小和自身LayoutParams决定，遵守以下规则：// LayoutParams.MATCH_PARENT: 精确模式，窗口大小// LayoutParams.WRAP_CONTENT: 最大模式，最大为窗口大小// 固定大小：精确模式，大小为LayoutParams的大小//实际上是调用DecorView的measure()方法 mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); //在view的measure()方法内部还调用了 onMeasure(widthMeasureSpec, heightMeasureSpec); //DecorView的父类是FrameLayout,在FrameLayout的onMeasure中调用了 child.measure(childWidthMeasureSpec, childHeightMeasureSpec);//因为是容器viewGroup，所以测量了自身需要在测量child控件 总结： viewGroup : measure -&gt; onMeasure(子控件的宽高) -&gt; setMeasuredDimension() -&gt; setMeasuredDimensionRaw(保存自己的宽高)view : measure -&gt; onMeasure() -&gt; setMeasuredDimension() -&gt; setMeasuredDimensionRaw(保存自己的宽高)自定义view不重写onMeasure方法，使用match_parent 和 wrap_content的效果是一样的 布局performLayout() ,回到performLayout(lp, desiredWindowWidth, desiredWindowHeight); //1931 ViewRootImpl.java 123456-&gt; host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight());-&gt; setFrame(l, t, r, b);//调用view.layout确定自身的位置，即确定mLeft,mTop,mRight,mBottom的值 总结：viewGroup: layout(确定自己的位置，4个点的位置)-&gt;onLayout(进行子view的布局)view: layout(确定自己的位置，4个点的位置) performDraw绘制 //2067 ViewRootImpl.java 12345678910111213141516-&gt; performDraw()-&gt; draw()-&gt; drawSoftware()-&gt; mView.draw(canvas);-&gt; /* * Draw traversal performs several drawing steps which must be executed * in the appropriate order: * * 1. Draw the background * 2. If necessary, save the canvas' layers to prepare for fading * 3. Draw view's content * 4. Draw children * 5. If necessary, draw the fading edges and restore layers * 6. Draw decorations (scrollbars for instance) */ 总结：viewGroup: 绘制背景drawBackground() 绘制自己onDraw() 绘制子view dispatchDraw() 绘制前景,滚动条等装饰onDrawForeground() view: 绘制背景drawBackground() 绘制自己onDraw() 绘制前景,滚动条等装饰onDrawForeground()]]></content>
  </entry>
  <entry>
    <title><![CDATA[红黑树]]></title>
    <url>%2F2019%2F08%2F05%2F%E7%BA%A2%E9%BB%91%E6%A0%91%2F</url>
    <content type="text"><![CDATA[二叉查找树（BST）定义：一颗二叉树，每个结点都有一个Comparable的键且每个结点的键都大于其左子树的任意结点的键而小于右子树的任意结点的键。 二叉查找树的图像形状 查找 插入 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public class BST&lt;Key extends Comparable&lt;Key&gt;, Value&gt; &#123; private Node root; private class Node &#123; private Key key; //键 private Value val; private Node left, right; //指向子树的链接 private int N; //以该结点为根的子树中的节点总数 public Node(Key key, Value val, int n) &#123; this.key = key; this.val = val; N = n; &#125; &#125; public int size() &#123; return size(root); &#125; private int size(Node x) &#123; if (x == null) &#123; return 0; &#125; else &#123; return x.N; &#125; &#125; //查找 public Value get(Key key) &#123; return get(root, key); &#125; private Value get(Node x, Key key) &#123; if (x == null) return null; int cmp = key.compareTo(x.key); if (cmp &lt; 0) return get(x.left, key); else if (cmp &gt; 0) return get(x.right, key); else return x.val; &#125; //插入 public void put(Key key, Value val) &#123; root = put(root, key, val); &#125; private Node put(Node x, Key key, Value val) &#123; if (x == null) return new Node(key, val, 1); int cmp = key.compareTo(x.key); if (cmp &lt; 0) x.left = put(x.left, key, val); else if (cmp &gt; 0) x.right = put(x.right, key, val); else x.val = val; x.N = size(x.left) + size(x.right) + 1; return x; &#125; //取最小key public Key min() &#123; return min(root).key; &#125; private Node min(Node x) &#123; if (x.left == null) return x; return min(x.left); &#125; //向下取之整 public Key floor(Key key) &#123; Node x = floor(root, key); if (x == null) return null; return x.key; &#125; private Node floor(Node x, Key key) &#123; if (x == null) return null; int cmp = key.compareTo(x.key); if (cmp == 0) return x; if (cmp &lt; 0) return floor(x.left, key); Node t = floor(x.right, key); if (t != null) return t; else return x; &#125; //max() //ceiling()&#125; 二分查找法 性能分析 平衡查找树2-3树定义：一颗2-3树或为空树，或为以下结点组成： 2-结点：含有一个键(及值)和两条链接，左链接指向的2-3树中的键都小于该结点，右链接指向的2-3树中的键都大于该结点。 3-结点：含有两个键(及值)和三条链接，左链接指向的2-3树中的键都小于该结点，中链接指向的2-3树中的键都位于该结点的两个键之间，右链接指向的2-3树中的键都大于该结点。 一颗完美平衡的2-3查找树中的所有空链接到根结点的距离都是相同的。 查找要判断一个键是否在树中，我们先将它和根结点中的键比较。如果它和其中的任何一个相等，查找命中。否则我们就根据比较的结果找到指向相应区间的链接，并在其指向的子树中递归地继续查找。如果这是个空链接，查找未命中。 插入 向2-结点插入新键 只要把这个2-结点替换为一个3-结点，将要插入的键保存在其中即可 向只有3-结点插入新键 创建一个4-结点很方便，因为很容易将它转换为一颗由3个2-结点组成的2-3树 向父节点为2-结点的3-结点插入新键 同上，但是不会为中键创建一个新结点，而是将其移动至原来的父结点中 向父节点为3-结点的3-结点插入新键 一直向上不断分解临时的4-结点并将中键插入更高的父结点，直至遇到一个2-结点并将它替换为一个不需要继续分解的3-结点，或者是到达3-结点的根 性能：一颗大小为N的2-3树，查找和插入操作访问的结点必然不超过logN个。高度在log3 N 与log2 N之间。 红黑二叉查找树一种等价的定义： 红链接均为左链接 没有任何一个结点同时和两条红链接相连 该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同。 红链接：将两个2-结点连接起来构成一个3-结点黑链接：2-3树中的普通链接 示例图 旋转 左旋 右旋 插入 新键最小 新键最大 新键介于中间 变色 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package redblack;public class RedBlackBST&lt;Key extends Comparable&lt;Key&gt;, Value&gt; &#123; private static final boolean RED = true; private static final boolean BLACK = false; private Node root; public void put(Key key, Value val) &#123; root = put(root, key, val); root.color = BLACK; &#125; private Node put(Node h, Key key, Value val) &#123; if (h == null) &#123; return new Node(key, val, 1, RED); &#125; int cmp = key.compareTo(h.key); if (cmp &lt; 0) h.left = put(h.left, key, val); else if (cmp &gt; 0) h.right = put(h.right, key, val); else h.val = val; if (isRed(h.right) &amp;&amp; !isRed(h.left)) h = rotateLeft(h); if (isRed(h.left) &amp;&amp; isRed(h.left.left)) h = rotateRight(h); if (isRed(h.left) &amp;&amp; isRed(h.right)) flipColors(h); h.N = size(h.left) + size(h.right) + 1; return h; &#125; private void flipColors(Node h) &#123; h.color = RED; h.left.color = BLACK; h.right.color = BLACK; &#125; private Node rotateRight(Node h) &#123; Node x = h.left; h.left = x.right; x.right = h; x.color = h.color; h.color = RED; x.N = h.N; h.N = size(h.left) + size(h.right) + 1; return x; &#125; private Node rotateLeft(Node h) &#123; Node x = h.right; h.right = x.left; x.left = h; x.color = h.color; h.color = RED; x.N = h.N; h.N = size(h.left) + size(h.right) + 1; return x; &#125; private boolean isRed(Node x) &#123; if (x == null) return false; else return x.color == RED; &#125; public int size() &#123; return size(root); &#125; private int size(Node x) &#123; if (x == null) &#123; return 0; &#125; else &#123; return x.N; &#125; &#125; private class Node &#123; private Key key; private Value val; private Node left, right; private int N; private boolean color; public Node(Key key, Value val, int n, boolean color) &#123; this.key = key; this.val = val; N = n; this.color = color; &#125; &#125;&#125; 结论：性能: 一颗大小为N的红黑树，根结点到任意结点的平均路径长度为logN。和典型的二叉查找树相比，构造的长度比它低40%左右。 顺序查询（无序链表） 最坏情况：查找（N） 插入（N）平均情况:查找(N/2) 插入(N) 二分查找（有序数组） 最坏情况：查找（logN） 插入（N）平均情况:查找(logN) 插入(N/2) 二叉树查找（BST） 最坏情况：查找（N） 插入（N）平均情况:查找(1.39logN) 插入(1.39logN) 2-3树查找（红黑树） 最坏情况：查找（2logN） 插入（2logN）平均情况:查找(1.00logN) 插入(1.00logN) 约束条件 节点只能是红色或黑色 根节点必须是黑色 所有NIL 节点都是黑色的 一条路径上不能出现相邻的两个红色节点 在任何递归子树内，根节点到叶子节点的所有路径上包含相同数目的黑色节点 左旋：左旋的过程是将x的右子树绕x逆时针旋转，使得x的右子树成为x的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。 treeMap 源码实现 1234567891011121314151617181920212223private void rotateLeft(TreeMap.Entry&lt;K, V&gt; p) &#123; if (p != null) &#123; TreeMap.Entry&lt;K, V&gt; r = p.right; p.right = r.left; if (r.left != null) &#123; r.left.parent = p; &#125; r.parent = p.parent; if (p.parent == null) &#123; this.root = r; &#125; else if (p.parent.left == p) &#123; p.parent.left = r; &#125; else &#123; p.parent.right = r; &#125; r.left = p; p.parent = r; &#125; &#125; 右旋：右旋的过程是将x的左子树绕x顺时针旋转，使得x的左子树成为x的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。 1234567891011121314151617181920212223private void rotateRight(TreeMap.Entry&lt;K, V&gt; p) &#123; if (p != null) &#123; TreeMap.Entry&lt;K, V&gt; l = p.left; p.left = l.right; if (l.right != null) &#123; l.right.parent = p; &#125; l.parent = p.parent; if (p.parent == null) &#123; this.root = l; &#125; else if (p.parent.right == p) &#123; p.parent.right = l; &#125; else &#123; p.parent.left = l; &#125; l.right = p; p.parent = l; &#125; &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[排序]]></title>
    <url>%2F2019%2F08%2F05%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[排序是将一组对象按照某种逻辑顺序重新排列的过程。在计算机早期，大家普遍认为30%的计算周期都用在排序上。如今这个比例下降，可能原因之一是如今的排序算法更高效了，而不是说排序的重要性降低了。 既然可以使用标准库中的排序算法，大家为什么还要研究排序呢？ 理解算法有助于解决类似的其他问题 这些算法很经典，优雅，值得去看。 应用于事务处理，组合优化，天体物理学，分子动力学，语言学，基因组学，天气预报等众多领域。其中，快速排序被誉为20世纪科学和工程领域的十大算法之一。 如何来判断算法的成本 计算比较和交换的数量。对于不交换元素的算法，则计算访问数组的次数。 排序算法的额外开销和运行时间同等重要。 12345678910public static boolean less(Comparable v, Comparable w)&#123; return v.comparableTo(w) &lt; 0;&#125;public static void exch(Comparable[] a, int i, int j)&#123; Comparable t = a[i]; a[i] = a[j]; a[j] = t;&#125; 选择排序原理： 找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置。再次，在剩下的元素中找到最小的元素，和数组的第二个元素交换位置，直到最后一个元素为止。 12345678910111213141516public class Selection&#123; public static void sort(Comparable[] a)&#123; int N = a.length(); for(int i = 0; i &lt; N; i ++)&#123; int min = i; //最小元素的索引 for(int j = i+1; j &lt; N; j++)&#123; if(less(a[j], a[min]))&#123; min = j; &#125; &#125; exch(a, i, min); &#125; &#125;&#125; 交换总次数：N比较总次数：N^2 / 2因此这个算法效率取决于比较的次数 运行时间与输入无关。 插入排序为了给插入的元素腾出空间，我们需要将数组的其他元素在插入之前都往右移一位。当索引到达数组的最右端的时候，数组排序就完成了。与选择排序不同的是，插入排序取决于输入元素的初始顺序。 123456789101112131415public class Insertion&#123; public static void sort(Comparable[] a)&#123; int N = a.length; for(int i = 1; i &lt; N; i++)&#123; //将a[i]插入到a[i-1], a[i-2],... for(int j = i; j &gt; 0 &amp;&amp; less(a[j], a[j-1]); j--)&#123; exch(a, a[j], a[j-1]); &#125; &#125; &#125;&#125; 交换总次数：最好的情况需要0次交换，最坏的情况需要N^2 / 2次交换比较总次数：最好的情况需要N-1次比较，最坏的情况需要N^2 / 2次比较 运行时间与输入有关。当对一个很大且已经有序，或者接近有序的数组进行排序会比随机顺序或者逆序数组排序快的多。 希尔排序希尔排序的思想是数组中任意间隔为h的元素都是有序的，这样的数组被称为h有序数组。它是基于插入排序的一种算法。当较大的数替换到后面去，就可以减少比较的次数。 12345678910111213141516171819202122232425public class Shell&#123; public static void sort(Comparable[] a)&#123; int N = a.length; int h = 1; while (h &lt; N /3 ) &#123; //1,4,13,40,121,... h = h * 3 + 1; &#125; while(h &gt;= 1)&#123; for(int i = h; h &lt; N; i++)&#123; //将a[j] 插入到a[i-h], a[i - 2*h], a[i - 3*h],... for(int j = i; j &gt;= h &amp;&amp; less(a[j], a[j-h]); j -= h)&#123; exch(a, j, j-h); &#125; &#125; h = h / 3; &#125; &#125;&#125; 希尔排序不需要额外的空间，而且代码量很小，当没有系统的排序函数可用时，值得优先考虑。 归并排序即两个有序的数组归并成为一个更大的有序数组，这样的递归排序算法成为归并排序。 有序容易，难在归并，所以是如何归并的呢？原地归并的抽象方法： 1234567891011121314151617public static void merge(Comparable[] a, int lo, int mid, int hi)&#123; //将数组[lo..mid]和[mid+1..hi]归并 int i = lo, j = mid+1; for(int k = lo; k &lt;= hi; k++)&#123; aux[k] = a[k]; //将a[lo..hi]复制到aux[lo..hi]中 &#125; for(int k = lo; k &lt;= hi; k++)&#123; if(i &gt; mid) a[k] = aux[j++]; //左半部分用尽了 if(j &gt; hi) a[k] = aux[i++]; //右半部分用尽 if(less(aux[j], aux[i])) a[k] = aux[j++]; //右半部分小于左半部分，取右半部分 else a[k] = aux[i++]; //取左半部分 &#125;&#125; 自顶向下的归并排序实现基于原地归并的抽象实现了另一种递归归并，这也是分治思想的一个典型的例子。 1234567891011121314151617181920public class Merge&#123; public static Comparable[] aux; public static void sort(Comparable[] a)&#123; aux = new Comparable[a.length]; sort(a, 0, a.length-1); &#125; public static void sort(Comparable[] a, int lo, int hi)&#123; if(hi &lt;= lo) return; //结束的标志位 int mid = lo + (hi - lo) / 2; sort(a, lo, mid); //将左半部分排序 sort(a, mid+1, hi); //将右半部分排序 merge(a, lo, mid, hi); //归并 &#125;&#125; 假设用一颗树来表示，n表示树的层数，k 表示0到k-1层， 因此，第k层有 2^k 个数组，每个数组中有 2^(n-k)个元素，所以每层比较的次数就是 2^k * 2^(n-k) = 2^n，n层的比较次数就是n*2^n = NlgN。 对于长度N的任意数组，自顶向下的归并排序需要1/2NlgN至NlgN次比较 证明: 令C(N)表示长度为N的数组需要比较的次数，我们有C(0)=C(1)=0,对于N&gt;1，我们有以下公式: C(N) = C(N/2) + C(N/2) + N //左半部分比较次数，右半部分比较次数，N表示归并需要比较的次数,最少归并比较的次数为N/2 假设N为2的幂，即N=2^n,可以得到 C(2^n) = 2C(2^(n-1)) + 2^n， 同时除以 2^n 有， C(2^n)/2^n = C(2^(n-1))/2^(n-1) + 1, 将这个公式代入 C(N/2)，有 C(2^(n-1))/2^(n-1) = C(2^(n-2))/2^(n-2) + 1，所以 C(2^n)/2^n = C(2^(n-2))/2^(n-2) + 1 + 1，所以重复n-1遍，便有 C(2^n)/2^n = C(2^0)/2^0) + n, 同时乘以 2^n, 有 C(2^n) = n*2^n = NlgN。 快速排序堆排序]]></content>
  </entry>
  <entry>
    <title><![CDATA[重构，改善既有的代码设计]]></title>
    <url>%2F2019%2F08%2F05%2F%E9%87%8D%E6%9E%84-%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E7%9A%84%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[以下将以6次重构的操作来实现一个简单的案例。例子：这是一个影片出租店用的程序，计算每一个顾客的消费金额并打印详单。操作者告诉程序：顾客租了哪些影片，租期多长，程序便根据租赁时间和影片的类型算出费用。影片分为三类：普通片，儿童片和新片。除了计算费用，还要为常客计算积分，积分会根据租片的种类是否为新片而有所不同。 首先提个问题：什么时候重构？ 看代码实现上面案例如下：Movie.java（影片实体类）12345678910111213141516171819202122232425262728293031public class Movie &#123; public static final int CHILEDRENS = 2; public static final int REGULAR = 0; public static final int NEW_RELEASE = 1; public Movie(String title, int priceCode) &#123; this.title = title; this.priceCode = priceCode; &#125; private String title; private int priceCode; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public int getPriceCode() &#123; return priceCode; &#125; public void setPriceCode(int priceCode) &#123; this.priceCode = priceCode; &#125;&#125; Rental.java(租赁类)123456789101112131415161718public class Rental &#123; private Movie movie; private int daysRented; public Rental(Movie movie, int daysRented) &#123; this.movie = movie; this.daysRented = daysRented; &#125; public int getDaysRented() &#123; return daysRented; &#125; public Movie getMovie() &#123; return movie; &#125;&#125; Customer.java(顾客租赁类)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class Customer &#123; private String name; private Vector rentals = new Vector(); public void addRental(Rental arg) &#123; rentals.addElement(arg); &#125; public String getName() &#123; return name; &#125; public String statement() &#123; double totalAmount = 0; int frequentRenterPoints = 0; Enumeration elements = rentals.elements(); StringBuilder result = new StringBuilder("Rental Record for " + getName() + "\n"); while (elements.hasMoreElements()) &#123; double thisAmount = 0; Rental each = (Rental) elements.nextElement(); switch (each.getMovie().getPriceCode()) &#123; case Movie.REGULAR: thisAmount += 2; if (each.getDaysRented() &gt; 2) &#123; thisAmount += (each.getDaysRented() - 2) * 1.5; &#125; break; case Movie.NEW_RELEASE: thisAmount += each.getDaysRented() * 3; break; case Movie.CHILEDRENS: thisAmount += 1.5; if (each.getDaysRented() &gt; 3) &#123; thisAmount += (each.getDaysRented() - 3) * 1.5; &#125; break; &#125; //add frequent renter points frequentRenterPoints ++; //add bonus for a two day new release rental if ((each.getMovie().getPriceCode() == Movie.NEW_RELEASE) &amp;&amp; each.getDaysRented() &gt; 1)&#123; frequentRenterPoints ++; &#125; //show figures for this rental result.append("\t").append(each.getMovie().getTitle()).append("\t").append(String.valueOf(thisAmount)).append("\n"); totalAmount += thisAmount; &#125; //add footer lines result.append("Amount owed is ").append(String.valueOf(totalAmount)).append("\n"); result.append("You earned ").append(String.valueOf(frequentRenterPoints)).append(" frequent renter points"); return result.toString(); &#125;&#125; 以上代码实现完全没有问题，但是能如果遇到以下这两个问题，就会突出臃肿，可扩展性差，难以维护等缺点了。 如果计费标准变化了？ 就需要找到每条case中的计费方式，整个switch语句会十分庞大。 如果想输出statement()中某个数据显示到表单或者被其他地方引用？ 没有任何方法独立提出来，导致重复引用的计算多处出现。 如果你发现自己需要为程序添加一个特性，而代码的结构使你无法很方便地达到目的，那就先重构那个程序，使特性的添加比较容易进行，然后再添加特性。 ###重构（一） 分解并重组statement()12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public String statement() &#123; double totalAmount = 0; int frequentRenterPoints = 0; Enumeration elements = rentals.elements(); StringBuilder result = new StringBuilder("Rental Record for " + getName() + "\n"); while (elements.hasMoreElements()) &#123; double thisAmount = 0; Rental each = (Rental) elements.nextElement(); thisAmount = amountFor(each); //add frequent renter points frequentRenterPoints ++; //add bonus for a two day new release rental if ((each.getMovie().getPriceCode() == Movie.NEW_RELEASE) &amp;&amp; each.getDaysRented() &gt; 1)&#123; frequentRenterPoints ++; &#125; //show figures for this rental result.append("\t").append(each.getMovie().getTitle()).append("\t").append(String.valueOf(thisAmount)).append("\n"); totalAmount += thisAmount; &#125; //add footer lines result.append("Amount owed is ").append(String.valueOf(totalAmount)).append("\n"); result.append("You earned ").append(String.valueOf(frequentRenterPoints)).append(" frequent renter points"); return result.toString(); &#125; private int amountFor(Rental each)&#123; int thisAmount = 0; switch (each.getMovie().getPriceCode()) &#123; case Movie.REGULAR: thisAmount += 2; if (each.getDaysRented() &gt; 2) &#123; thisAmount += (each.getDaysRented() - 2) * 1.5; &#125; break; case Movie.NEW_RELEASE: thisAmount += each.getDaysRented() * 3; break; case Movie.CHILEDRENS: thisAmount += 1.5; if (each.getDaysRented() &gt; 3) &#123; thisAmount += (each.getDaysRented() - 3) * 1.5; &#125; break; &#125; return thisAmount; &#125; 每次做完一次这样的修改都要编译并测试。这次测试发现错误了吧。故意把返回的double改成了int类型。 就是为了告诉我们每次修改都要非常小心，并且编译测试，不但不会浪费时间，反而会节省大量的调试时间。 ###重构（二） 修改函数名称/参数名称123456789101112131415161718192021private double amountFor(Rental rental)&#123; double result = 0; switch (rental.getMovie().getPriceCode()) &#123; case Movie.REGULAR: result += 2; if (rental.getDaysRented() &gt; 2) &#123; result += (rental.getDaysRented() - 2) * 1.5; &#125; break; case Movie.NEW_RELEASE: result += rental.getDaysRented() * 3; break; case Movie.CHILEDRENS: result += 1.5; if (rental.getDaysRented() &gt; 3) &#123; result += (rental.getDaysRented() - 3) * 1.5; &#125; break; &#125; return result; &#125; 任何一个傻瓜都可以写出计算机可以理解的代码，唯有写出人类容易理解的代码，才是优秀的程序员。 ###重构（三） 搬移函数（移动到它该到的地方去）123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Customer &#123; private String name; private Vector rentals = new Vector(); public void addRental(Rental arg) &#123; rentals.addElement(arg); &#125; public String getName() &#123; return name; &#125; public String statement() &#123; double totalAmount = 0; int frequentRenterPoints = 0; Enumeration elements = rentals.elements(); StringBuilder result = new StringBuilder("Rental Record for " + getName() + "\n"); while (elements.hasMoreElements()) &#123; double thisAmount = 0; Rental each = (Rental) elements.nextElement(); thisAmount = amountFor(each); //add frequent renter points frequentRenterPoints ++; //add bonus for a two day new release rental if ((each.getMovie().getPriceCode() == Movie.NEW_RELEASE) &amp;&amp; each.getDaysRented() &gt; 1)&#123; frequentRenterPoints ++; &#125; //show figures for this rental result.append("\t").append(each.getMovie().getTitle()).append("\t").append(String.valueOf(thisAmount)).append("\n"); totalAmount += thisAmount; &#125; //add footer lines result.append("Amount owed is ").append(String.valueOf(totalAmount)).append("\n"); result.append("You earned ").append(String.valueOf(frequentRenterPoints)).append(" frequent renter points"); return result.toString(); &#125; private double amountFor(Rental rental)&#123; return rental.getCharge(); &#125;&#125; Rental.java类12345678910111213141516171819202122232425262728293031323334353637383940public class Rental &#123; private Movie movie; private int daysRented; public Rental(Movie movie, int daysRented) &#123; this.movie = movie; this.daysRented = daysRented; &#125; public int getDaysRented() &#123; return daysRented; &#125; public Movie getMovie() &#123; return movie; &#125; double getCharge()&#123; double result = 0; switch (getMovie().getPriceCode()) &#123; case Movie.REGULAR: result += 2; if (getDaysRented() &gt; 2) &#123; result += (getDaysRented() - 2) * 1.5; &#125; break; case Movie.NEW_RELEASE: result += getDaysRented() * 3; break; case Movie.CHILEDRENS: result += 1.5; if (getDaysRented() &gt; 3) &#123; result += (getDaysRented() - 3) * 1.5; &#125; break; &#125; return result; &#125;&#125; 重构（四）提炼函数(越细小的函数功能越明确)/去除临时变量(使结构更清晰)1234567891011121314151617181920212223242526272829303132333435public String statement() &#123; Enumeration elements = rentals.elements(); StringBuilder result = new StringBuilder("Rental Record for " + getName() + "\n"); while (elements.hasMoreElements()) &#123; Rental each = (Rental) elements.nextElement(); //show figures for this rental result.append("\t").append(each.getMovie().getTitle()).append("\t").append(String.valueOf(each.getCharge())).append("\n"); &#125; //add footer lines result.append("Amount owed is ").append(String.valueOf(getTotalCharge())).append("\n"); result.append("You earned ").append(String.valueOf(getTotalFrequentRenterPoints())).append(" frequent renter points"); return result.toString(); &#125; private double getTotalCharge()&#123; double result = 0; Enumeration enumeration = rentals.elements(); while (enumeration.hasMoreElements())&#123; Rental each = (Rental) enumeration.nextElement(); result += each.getCharge(); &#125; return result; &#125; private int getTotalFrequentRenterPoints()&#123; int result = 0; Enumeration enumeration = rentals.elements(); while (enumeration.hasMoreElements())&#123; Rental each = (Rental) enumeration.nextElement(); result += each.getFrequentRenterPoints(); &#125; return result; &#125; Rental.java类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Rental &#123; private Movie movie; private int daysRented; public Rental(Movie movie, int daysRented) &#123; this.movie = movie; this.daysRented = daysRented; &#125; public int getDaysRented() &#123; return daysRented; &#125; public Movie getMovie() &#123; return movie; &#125; double getCharge()&#123; double result = 0; switch (getMovie().getPriceCode()) &#123; case Movie.REGULAR: result += 2; if (getDaysRented() &gt; 2) &#123; result += (getDaysRented() - 2) * 1.5; &#125; break; case Movie.NEW_RELEASE: result += getDaysRented() * 3; break; case Movie.CHILEDRENS: result += 1.5; if (getDaysRented() &gt; 3) &#123; result += (getDaysRented() - 3) * 1.5; &#125; break; &#125; return result; &#125; int getFrequentRenterPoints()&#123; if ((getMovie().getPriceCode() == Movie.NEW_RELEASE) &amp;&amp; getDaysRented() &gt; 1)&#123; return 2; &#125;else &#123; return 1; &#125; &#125;&#125; ###重构（五） 多态来提炼switch()语句 这里不直接抽象Movie类，是因为Movie类有自己的属性和生命周期。所以State模式的应用可以很好的解决这个问题。 Movie.java类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Movie &#123; public static final int CHILEDRENS = 2; public static final int REGULAR = 0; public static final int NEW_RELEASE = 1; public Movie(String title, int priceCode) &#123; this.title = title; setPriceCode(priceCode); &#125; public void setPriceCode(int arg) &#123; switch (arg) &#123; case REGULAR: price = new RegularPrice(); break; case CHILEDRENS: price = new ChildrensPrice(); break; case NEW_RELEASE: price = new NewReleasePrice(); break; default: throw new IllegalArgumentException("incorrect price code"); &#125; &#125; private String title; private Price price; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public Price getPrice() &#123; return price; &#125; public void setPrice(Price price) &#123; this.price = price; &#125; double getCharge(int daysRented) &#123; return price.getCharge(daysRented); &#125; int getFrequentRenterPoints(int daysRented) &#123; return price.getFrequentRenterPoints(daysRented); &#125;&#125; Price.java类12345678910111213141516171819202122232425262728293031323334abstract class Price &#123; abstract int getPriceCode(); double getCharge(int daysRented)&#123; double result = 0; switch (getPriceCode()) &#123; case Movie.REGULAR: result += 2; if (daysRented &gt; 2) &#123; result += (daysRented - 2) * 1.5; &#125; break; case Movie.NEW_RELEASE: result += daysRented * 3; break; case Movie.CHILEDRENS: result += 1.5; if (daysRented &gt; 3) &#123; result += (daysRented - 3) * 1.5; &#125; break; &#125; return result; &#125; int getFrequentRenterPoints(int daysRented) &#123; if ((getPriceCode() == Movie.NEW_RELEASE) &amp;&amp; daysRented &gt; 1) &#123; return 2; &#125; else &#123; return 1; &#125; &#125;&#125; NewReleasePrice.java类123456public class NewReleasePrice extends Price &#123; @Override int getPriceCode() &#123; return Movie.NEW_RELEASE; &#125;&#125; 其他两个实现类同NewReleasePrice类，就不列出来了。 ###重构（六） 继承12345678910abstract class Price &#123; abstract int getPriceCode(); abstract double getCharge(int daysRented); int getFrequentRenterPoints(int daysRented) &#123; return 1; &#125;&#125; NewReleasePrice.java类12345678910111213141516public class NewReleasePrice extends Price &#123; @Override int getPriceCode() &#123; return Movie.NEW_RELEASE; &#125; @Override double getCharge(int daysRented) &#123; return daysRented * 3; &#125; @Override int getFrequentRenterPoints(int daysRented) &#123; return (daysRented &gt; 1) ? 2 : 1; &#125;&#125; 前面列出的技术点仅仅只是一个起点，使你登堂入室之前的大门。如果没有这些技术，你根本无法对运行的程序进行任何设计上的改动。有了这些技术，你仍然做不到，但起码可以开始尝试了。]]></content>
  </entry>
</search>

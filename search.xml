<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[binder驱动分析]]></title>
    <url>%2F2019%2F12%2F20%2Fbinder%2F</url>
    <content type="text"><![CDATA[startActivity执行的时候跨进程了吗？ 如果是跨进程，那么是于哪个进程通信呢？ service, broadcast这些呢？ binder的概念 Binder是android提供的一种IPC机制，Binder通信机制类似于C/S架构，除了C/S架构外，还有一个管理全局的ServiceManager 穿梭于各个进程之间的binder servicemanager 的作用是什么？ servicemanger 是如何告知binder驱动它是binder机制的上下文管理者？ MediaServer作为例子MediaServer包括以下这些服务： AudioFlinger AudioPolicService MediaPlayerService CameraService 来看下MerdiaServer入口的源码 123456789101112131415int main(int argc __unused, char **argv __unused)&#123; signal(SIGPIPE, SIG_IGN); sp&lt;ProcessState&gt; proc(ProcessState::self()); sp&lt;IServiceManager&gt; sm(defaultServiceManager()); ALOGI("ServiceManager: %p", sm.get()); InitializeIcuOrDie(); MediaPlayerService::instantiate(); ResourceManagerService::instantiate(); registerExtensions(); ProcessState::self()-&gt;startThreadPool(); IPCThreadState::self()-&gt;joinThreadPool();&#125; ProcessState 1234567891011sp&lt;ProcessState&gt; ProcessState::self()&#123; //可以看得出这是一个单例：从这里得到一个信息，每个进程只有一个ProcessState对象 Mutex::Autolock _l(gProcessMutex); if (gProcess != NULL) &#123; return gProcess; &#125; gProcess = new ProcessState("/dev/binder"); return gProcess;&#125; ProcessState的构造函数 123456789101112131415161718192021222324252627282930ProcessState::ProcessState(const char *driver) : mDriverName(String8(driver)) , mDriverFD(open_driver(driver)) //打开/dev/binder 设备 , mVMStart(MAP_FAILED) //映射内存的起始地址 , mThreadCountLock(PTHREAD_MUTEX_INITIALIZER) , mThreadCountDecrement(PTHREAD_COND_INITIALIZER) , mExecutingThreadsCount(0) , mMaxThreads(DEFAULT_MAX_BINDER_THREADS) , mStarvationStartTimeMs(0) , mManagesContexts(false) , mBinderContextCheckFunc(NULL) , mBinderContextUserData(NULL) , mThreadPoolStarted(false) , mThreadPoolSeq(1)&#123; if (mDriverFD &gt;= 0) &#123; // mmap the binder, providing a chunk of virtual address space to receive transactions. mVMStart = mmap(0, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, 0); if (mVMStart == MAP_FAILED) &#123; // *sigh* ALOGE("Using %s failed: unable to mmap transaction memory.\n", mDriverName.c_str()); close(mDriverFD); mDriverFD = -1; mDriverName.clear(); &#125; &#125; LOG_ALWAYS_FATAL_IF(mDriverFD &lt; 0, "Binder driver could not be opened. Terminating.");&#125; ProcessState做了什么？总结一下： 打开/dev/binder设备，相当于与内核的Binder驱动有了交互的通道(ioctl)。 mmap为Binder驱动分配一块内存来接收数据。 ProcessState具有唯一性，因此一个进程只会打开一次设备 IServiceManager 1234567891011121314151617sp&lt;IServiceManager&gt; defaultServiceManager()&#123; if (gDefaultServiceManager != NULL) return gDefaultServiceManager; &#123; AutoMutex _l(gDefaultServiceManagerLock); while (gDefaultServiceManager == NULL) &#123; gDefaultServiceManager = interface_cast&lt;IServiceManager&gt;( ProcessState::self()-&gt;getContextObject(NULL)); if (gDefaultServiceManager == NULL) sleep(1); &#125; &#125; return gDefaultServiceManager;&#125; 12345sp&lt;IBinder&gt; ProcessState::getContextObject(const sp&lt;IBinder&gt;&amp; /*caller*/)&#123; return getStrongProxyForHandle(0); //这个其实是个资源数组&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(int32_t handle)&#123; sp&lt;IBinder&gt; result; AutoMutex _l(mLock); handle_entry* e = lookupHandleLocked(handle); if (e != NULL) &#123; // We need to create a new BpBinder if there isn't currently one, OR we // are unable to acquire a weak reference on this current one. See comment // in getWeakProxyForHandle() for more info about this. IBinder* b = e-&gt;binder; if (b == NULL || !e-&gt;refs-&gt;attemptIncWeak(this)) &#123; if (handle == 0) &#123; // Special case for context manager... // The context manager is the only object for which we create // a BpBinder proxy without already holding a reference. // Perform a dummy transaction to ensure the context manager // is registered before we create the first local reference // to it (which will occur when creating the BpBinder). // If a local reference is created for the BpBinder when the // context manager is not present, the driver will fail to // provide a reference to the context manager, but the // driver API does not return status. // // Note that this is not race-free if the context manager // dies while this code runs. // // TODO: add a driver API to wait for context manager, or // stop special casing handle 0 for context manager and add // a driver API to get a handle to the context manager with // proper reference counting. Parcel data; status_t status = IPCThreadState::self()-&gt;transact( 0, IBinder::PING_TRANSACTION, data, NULL, 0); if (status == DEAD_OBJECT) return NULL; &#125; b = BpBinder::create(handle); e-&gt;binder = b; if (b) e-&gt;refs = b-&gt;getWeakRefs(); result = b; &#125; else &#123; // This little bit of nastyness is to allow us to add a primary // reference to the remote proxy when this team doesn't have one // but another team is sending the handle to us. result.force_set(b); e-&gt;refs-&gt;decWeak(this); &#125; &#125; return result; //这里的hande=0,所以此处的result为BpBinder::create(handle)&#125; 这里引出了一个BpBinder的概念，BpBinder和BBinder都是IBinder类派生而来，BpBinder和BBinder是一一对应的，上面创建了BpBinder，对应的BBinder会找对应的handle等于0的BBinder, 在android系统中handle=0的是ServiceManager BpBinder 看得出interface_cast(ProcessState::self()-&gt;getContextObject(NULL));相当于interface_cast(new BpBinder(0)); IInterface.h 123456template&lt;typename INTERFACE&gt;inline sp&lt;INTERFACE&gt; interface_cast(const sp&lt;IBinder&gt;&amp; obj)&#123; return INTERFACE::asInterface(obj);&#125; 模板函数,所以interface_cast()相当于 12345inline sp&lt;IServiceManager&gt; interface_cast(const sp&lt;IBinder&gt;&amp; obj)&#123; return IServiceManager::asInterface(obj);&#125; 所以回过头来再看IServiceManager.h这个类 123//这里我们特别需要关注下这个宏DECLARE_META_INTERFACE(ServiceManager) 这个宏的定义在IInterface.h文件中 12345678#define DECLARE_META_INTERFACE(INTERFACE) \ static const ::android::String16 descriptor; \ static ::android::sp&lt;I##INTERFACE&gt; asInterface( \ const ::android::sp&lt;::android::IBinder&gt;&amp; obj); \ virtual const ::android::String16&amp; getInterfaceDescriptor() const; \ I##INTERFACE(); \ virtual ~I##INTERFACE(); 我们将ServiceManager对宏定义替换下，得到如下： 12345678#define DECLARE_META_INTERFACE(INTERFACE) \ static const ::android::String16 descriptor; \ static ::android::sp&lt;ServiceManager&gt; asInterface( \ const ::android::sp&lt;::android::IBinder&gt;&amp; obj); \ virtual const ::android::String16&amp; getInterfaceDescriptor() const; \ ServiceManager(); \ virtual ~ServiceManager(); IServiceManager对IMPLEMENT_META_INTERFACE宏的使用如下： 12IMPLEMENT_META_INTERFACE(ServiceManager, "android.os.IServiceManager"); 对宏定义展开便是如下所示： 1234567891011121314151617181920212223#define IMPLEMENT_META_INTERFACE(INTERFACE, NAME) \ const ::android::String16 IServiceManager::descriptor("android.os.IServiceManager"); \ const ::android::String16&amp; \ IServiceManager::getInterfaceDescriptor() const &#123; \ return IServiceManager::descriptor; \ &#125; \ ::android::sp&lt;IServiceManager&gt; IServiceManager::asInterface( \ const ::android::sp&lt;::android::IBinder&gt;&amp; obj) \ &#123; \ ::android::sp&lt;IServiceManager&gt; intr; \ if (obj != NULL) &#123; \ intr = static_cast&lt;IServiceManager*&gt;( \ obj-&gt;queryLocalInterface( \ IServiceManager::descriptor).get()); \ if (intr == NULL) &#123; \ intr = new BpServiceManager(obj); \ &#125; \ &#125; \ return intr; \ &#125; \ IServiceManager::IServiceManager() &#123; &#125; \ IServiceManager::~IServiceManager() &#123; &#125; \ 从上面的代码上可以看出asInterface得到的是一个BpServiceManager对象。简单总结一下：上面传递new BpBinder(0)作为参数，通过IServiceManager::asInterface()方法得到一个BpServiceManagerr对象。 BpServiceManager又是什么鬼？ 来看下BpServiceManager的源码,还是在IServiceManager.cpp类中 12345678910class BpServiceManager : public BpInterface&lt;IServiceManager&gt;&#123;public: explicit BpServiceManager(const sp&lt;IBinder&gt;&amp; impl) : BpInterface&lt;IServiceManager&gt;(impl) //这里知道传进来的impl就是BpBinder() &#123; &#125; ... 从下面转换的代码中可以看出remote就是BpBinder 12345678//http://www.androidos.net.cn/android/9.0.0_r8/xref/frameworks/native/libs/binder/include/binder/IInterface.htemplate&lt;typename INTERFACE&gt;inline BpInterface&lt;INTERFACE&gt;::BpInterface(const sp&lt;IBinder&gt;&amp; remote) : BpRefBase(remote)&#123;&#125; 因此BpServiceManager实现IServiceManager的业务函数，而BpBinder作为通信对象。总结：defaultServiceManager()实际上像是初始化了BpServiceManager对象，以及建立了以BpBinder作为通信参数的通道. 接下来继续分析MediaPlayerService.cpp 123456//注册服务,defaultServiceManager()函数其实得到的是BpServiceManager对象void MediaPlayerService::instantiate() &#123; defaultServiceManager()-&gt;addService( String16("media.player"), new MediaPlayerService());&#125; 那么就看下BpServiceManager.addService()业务方法 123456789101112virtual status_t addService(const String16&amp; name, const sp&lt;IBinder&gt;&amp; service, bool allowIsolated, int dumpsysPriority) &#123; Parcel data, reply; //打包数据到data data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor()); data.writeString16(name); data.writeStrongBinder(service); data.writeInt32(allowIsolated ? 1 : 0); data.writeInt32(dumpsysPriority); status_t err = remote()-&gt;transact(ADD_SERVICE_TRANSACTION, data, &amp;reply);//上面提到过remote就是BpBinder，所以这里就是请求的数据data打包给了BpBinder通信层 return err == NO_ERROR ? reply.readExceptionCode() : err; &#125; 接下来再看下BpBinder::transact()方法 1234567891011121314status_t BpBinder::transact( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)&#123; // Once a binder has died, it will never come back to life. if (mAlive) &#123; status_t status = IPCThreadState::self()-&gt;transact( mHandle, code, data, reply, flags);//这里把工作交给了IPCThreadState去处理了 if (status == DEAD_OBJECT) mAlive = 0; return status; &#125; return DEAD_OBJECT;&#125; 继续看IPCThreadState::self() 1234567891011121314151617181920212223242526272829303132333435363738/*TLS是Thread Local Stroage(线程本地存储空间)的简称。这种空间每个线程都会有，线程间不共享这些空间。通过pthread_getspecific()可以获取这些空间有pthread_getspecific的地方，肯定有调用pthread_setspecifi的地方这里创建了IPCThreadState指针*/IPCThreadState* IPCThreadState::self()&#123; if (gHaveTLS) &#123;restart: const pthread_key_t k = gTLS; IPCThreadState* st = (IPCThreadState*)pthread_getspecific(k); if (st) return st; return new IPCThreadState; &#125; if (gShutdown) &#123; ALOGW("Calling IPCThreadState::self() during shutdown is dangerous, expect a crash.\n"); return NULL; &#125; pthread_mutex_lock(&amp;gTLSMutex); if (!gHaveTLS) &#123; int key_create_value = pthread_key_create(&amp;gTLS, threadDestructor); if (key_create_value != 0) &#123; pthread_mutex_unlock(&amp;gTLSMutex); ALOGW("IPCThreadState::self() unable to create TLS key, expect a crash: %s\n", strerror(key_create_value)); return NULL; &#125; gHaveTLS = true; &#125; pthread_mutex_unlock(&amp;gTLSMutex); goto restart;&#125; IPCThreadState的构造函数 1234567891011121314151617181920IPCThreadState::IPCThreadState() : mProcess(ProcessState::self()), mStrictModePolicy(0), mLastTransactionBinderFlags(0)&#123; //把自己设置到线程本地存储中 pthread_setspecific(gTLS, this); clearCaller(); mIn.setDataCapacity(256); mOut.setDataCapacity(256);&#125;/*每个线程都有一个IPCThreadState，每个IPCThreadState都有一个mIn,一个mOut,mIn：接收来自Binder设备的数据mOut: 存储发往Binder设备的数据*/ ok, 以上获得了IPCThreadState对象，下一步看transact()方法 12345678910111213141516171819202122232425262728293031status_t IPCThreadState::transact(int32_t handle, uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)&#123; ... err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, NULL); if (err != NO_ERROR) &#123; if (reply) reply-&gt;setError(err); return (mLastError = err); &#125; if ((flags &amp; TF_ONE_WAY) == 0) &#123; #if 0 if (code == 4) &#123; // relayout ALOGI("&gt;&gt;&gt;&gt;&gt;&gt; CALLING transaction 4"); &#125; else &#123; ALOGI("&gt;&gt;&gt;&gt;&gt;&gt; CALLING transaction %d", code); &#125; #endif if (reply) &#123; err = waitForResponse(reply); &#125; else &#123; Parcel fakeReply; err = waitForResponse(&amp;fakeReply); &#125; ... return err;&#125; 继续分析writeTransactionData()方法 123456789101112131415161718192021222324252627282930313233343536status_t IPCThreadState::writeTransactionData(int32_t cmd, uint32_t binderFlags,956 int32_t handle, uint32_t code, const Parcel&amp; data, status_t* statusBuffer)957&#123;958 binder_transaction_data tr;959960 tr.target.ptr = 0; /* Don't pass uninitialized stack data to a remote process */961 tr.target.handle = handle; //用来表识目的端，其中0就是ServiceManager的标志, 这里的handle是BpBinder构造方法里传过来的handler==0962 tr.code = code; //code消息码，用来switch/case963 tr.flags = binderFlags;964 tr.cookie = 0;965 tr.sender_pid = 0; //进程id966 tr.sender_euid = 0; //用户id967968 const status_t err = data.errorCheck();969 if (err == NO_ERROR) &#123;970 tr.data_size = data.ipcDataSize();971 tr.data.ptr.buffer = data.ipcData();972 tr.offsets_size = data.ipcObjectsCount()*sizeof(binder_size_t);973 tr.data.ptr.offsets = data.ipcObjects();974 &#125; else if (statusBuffer) &#123;975 tr.flags |= TF_STATUS_CODE;976 *statusBuffer = err;977 tr.data_size = sizeof(status_t);978 tr.data.ptr.buffer = reinterpret_cast&lt;uintptr_t&gt;(statusBuffer);979 tr.offsets_size = 0;980 tr.data.ptr.offsets = 0;981 &#125; else &#123;982 return (mLastError = err);983 &#125;984985 mOut.writeInt32(cmd);//把命令写到mOut中986 mOut.write(&amp;tr, sizeof(tr));987988 return NO_ERROR;989&#125; status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult) 123456789101112131415161718192021222324252627282930313233343536status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)&#123; uint32_t cmd; int32_t err; while (1) &#123; if ((err=talkWithDriver()) &lt; NO_ERROR) break; err = mIn.errorCheck(); if (err &lt; NO_ERROR) break; if (mIn.dataAvail() == 0) continue; cmd = (uint32_t)mIn.readInt32(); IF_LOG_COMMANDS() &#123; alog &lt;&lt; "Processing waitForResponse Command: " &lt;&lt; getReturnString(cmd) &lt;&lt; endl; &#125; ... default: err = executeCommand(cmd); if (err != NO_ERROR) goto finish; break; &#125; finish: if (err != NO_ERROR) &#123; if (acquireResult) *acquireResult = err; if (reply) reply-&gt;setError(err); mLastError = err; &#125; return err;&#125; 来看下talkWithDriver()方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103status_t IPCThreadState::talkWithDriver(bool doReceive)853&#123;854 if (mProcess-&gt;mDriverFD &lt;= 0) &#123;855 return -EBADF;856 &#125;857858 binder_write_read bwr;//用来与binder设备交换数据的结构859860 // Is the read buffer empty?861 const bool needRead = mIn.dataPosition() &gt;= mIn.dataSize();862863 // We don't want to write anything if we are still reading864 // from data left in the input buffer and the caller865 // has requested to read the next data.866 const size_t outAvail = (!doReceive || needRead) ? mOut.dataSize() : 0;867868 bwr.write_size = outAvail;869 bwr.write_buffer = (uintptr_t)mOut.data();870871 // This is what we'll read.872 if (doReceive &amp;&amp; needRead) &#123;873 bwr.read_size = mIn.dataCapacity();//接收缓冲区信息874 bwr.read_buffer = (uintptr_t)mIn.data();875 &#125; else &#123;876 bwr.read_size = 0;877 bwr.read_buffer = 0;878 &#125;879880 IF_LOG_COMMANDS() &#123;881 TextOutput::Bundle _b(alog);882 if (outAvail != 0) &#123;883 alog &lt;&lt; "Sending commands to driver: " &lt;&lt; indent;884 const void* cmds = (const void*)bwr.write_buffer;885 const void* end = ((const uint8_t*)cmds)+bwr.write_size;886 alog &lt;&lt; HexDump(cmds, bwr.write_size) &lt;&lt; endl;887 while (cmds &lt; end) cmds = printCommand(alog, cmds);888 alog &lt;&lt; dedent;889 &#125;890 alog &lt;&lt; "Size of receive buffer: " &lt;&lt; bwr.read_size891 &lt;&lt; ", needRead: " &lt;&lt; needRead &lt;&lt; ", doReceive: " &lt;&lt; doReceive &lt;&lt; endl;892 &#125;893894 // Return immediately if there is nothing to do.895 if ((bwr.write_size == 0) &amp;&amp; (bwr.read_size == 0)) return NO_ERROR;896897 bwr.write_consumed = 0;898 bwr.read_consumed = 0;899 status_t err;900 do &#123;901 IF_LOG_COMMANDS() &#123;902 alog &lt;&lt; "About to read/write, write size = " &lt;&lt; mOut.dataSize() &lt;&lt; endl;903 &#125;904#if defined(__ANDROID__)905 if (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= 0) //ioctl. 原来是ioctl通信的方式906 err = NO_ERROR;907 else908 err = -errno;909#else910 err = INVALID_OPERATION;911#endif912 if (mProcess-&gt;mDriverFD &lt;= 0) &#123;913 err = -EBADF;914 &#125;915 IF_LOG_COMMANDS() &#123;916 alog &lt;&lt; "Finished read/write, write size = " &lt;&lt; mOut.dataSize() &lt;&lt; endl;917 &#125;918 &#125; while (err == -EINTR);919920 IF_LOG_COMMANDS() &#123;921 alog &lt;&lt; "Our err: " &lt;&lt; (void*)(intptr_t)err &lt;&lt; ", write consumed: "922 &lt;&lt; bwr.write_consumed &lt;&lt; " (of " &lt;&lt; mOut.dataSize()923 &lt;&lt; "), read consumed: " &lt;&lt; bwr.read_consumed &lt;&lt; endl;924 &#125;925926 if (err &gt;= NO_ERROR) &#123;927 if (bwr.write_consumed &gt; 0) &#123;928 if (bwr.write_consumed &lt; mOut.dataSize())929 mOut.remove(0, bwr.write_consumed);930 else &#123;931 mOut.setDataSize(0);932 processPostWriteDerefs();933 &#125;934 &#125;935 if (bwr.read_consumed &gt; 0) &#123;936 mIn.setDataSize(bwr.read_consumed);937 mIn.setDataPosition(0);938 &#125;939 IF_LOG_COMMANDS() &#123;940 TextOutput::Bundle _b(alog);941 alog &lt;&lt; "Remaining data size: " &lt;&lt; mOut.dataSize() &lt;&lt; endl;942 alog &lt;&lt; "Received commands from driver: " &lt;&lt; indent;943 const void* cmds = mIn.data();944 const void* end = mIn.data() + mIn.dataSize();945 alog &lt;&lt; HexDump(cmds, mIn.dataSize()) &lt;&lt; endl;946 while (cmds &lt; end) cmds = printReturnCommand(alog, cmds);947 alog &lt;&lt; dedent;948 &#125;949 return NO_ERROR;950 &#125;951952 return err;953&#125; 再看看status_t IPCThreadState::executeCommand(int32_t cmd)方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131148status_t IPCThreadState::executeCommand(int32_t cmd)999&#123;1000 BBinder* obj;1001 RefBase::weakref_type* refs;1002 status_t result = NO_ERROR;10031004 switch ((uint32_t)cmd) &#123;1005 ...10761077 case BR_TRANSACTION:1078 &#123;1079 binder_transaction_data tr;1080 result = mIn.read(&amp;tr, sizeof(tr));1081 ALOG_ASSERT(result == NO_ERROR,1082 "Not enough command data for brTRANSACTION");1083 if (result != NO_ERROR) break;10841085 Parcel buffer;1086 buffer.ipcSetDataReference(1087 reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer),1088 tr.data_size,1089 reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets),1090 tr.offsets_size/sizeof(binder_size_t), freeBuffer, this);10911092 const pid_t origPid = mCallingPid;1093 const uid_t origUid = mCallingUid;1094 const int32_t origStrictModePolicy = mStrictModePolicy;1095 const int32_t origTransactionBinderFlags = mLastTransactionBinderFlags;10961097 mCallingPid = tr.sender_pid;1098 mCallingUid = tr.sender_euid;1099 mLastTransactionBinderFlags = tr.flags;11001101 //ALOGI("&gt;&gt;&gt;&gt; TRANSACT from pid %d uid %d\n", mCallingPid, mCallingUid);11021103 Parcel reply;1104 status_t error;1105 IF_LOG_TRANSACTIONS() &#123;1106 TextOutput::Bundle _b(alog);1107 alog &lt;&lt; "BR_TRANSACTION thr " &lt;&lt; (void*)pthread_self()1108 &lt;&lt; " / obj " &lt;&lt; tr.target.ptr &lt;&lt; " / code "1109 &lt;&lt; TypeCode(tr.code) &lt;&lt; ": " &lt;&lt; indent &lt;&lt; buffer1110 &lt;&lt; dedent &lt;&lt; endl1111 &lt;&lt; "Data addr = "1112 &lt;&lt; reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer)1113 &lt;&lt; ", offsets addr="1114 &lt;&lt; reinterpret_cast&lt;const size_t*&gt;(tr.data.ptr.offsets) &lt;&lt; endl;1115 &#125;1116 if (tr.target.ptr) &#123;1117 // We only have a weak reference on the target object, so we must first try to1118 // safely acquire a strong reference before doing anything else with it.1119 if (reinterpret_cast&lt;RefBase::weakref_type*&gt;(1120 tr.target.ptr)-&gt;attemptIncStrong(this)) &#123;1121 error = reinterpret_cast&lt;BBinder*&gt;(tr.cookie)-&gt;transact(tr.code, buffer,1122 &amp;reply, tr.flags); //BBinder,实际上实现的是BnServiceXXX对象1123 reinterpret_cast&lt;BBinder*&gt;(tr.cookie)-&gt;decStrong(this);1124 &#125; else &#123;1125 error = UNKNOWN_TRANSACTION;1126 &#125;11271128 &#125; else &#123;1129 error = the_context_object-&gt;transact(tr.code, buffer, &amp;reply, tr.flags);1130 &#125;11311132 //ALOGI("&lt;&lt;&lt;&lt; TRANSACT from pid %d restore pid %d uid %d\n",1133 // mCallingPid, origPid, origUid);11341135 if ((tr.flags &amp; TF_ONE_WAY) == 0) &#123;1136 LOG_ONEWAY("Sending reply to %d!", mCallingPid);1137 if (error &lt; NO_ERROR) reply.setError(error);1138 sendReply(reply, 0);1139 &#125; else &#123;1140 LOG_ONEWAY("NOT sending reply to %d!", mCallingPid);1141 &#125;11421143 mCallingPid = origPid;1144 mCallingUid = origUid;1145 mStrictModePolicy = origStrictModePolicy;1146 mLastTransactionBinderFlags = origTransactionBinderFlags;11471148 IF_LOG_TRANSACTIONS() &#123;1149 TextOutput::Bundle _b(alog);1150 alog &lt;&lt; "BC_REPLY thr " &lt;&lt; (void*)pthread_self() &lt;&lt; " / obj "1151 &lt;&lt; tr.target.ptr &lt;&lt; ": " &lt;&lt; indent &lt;&lt; reply &lt;&lt; dedent &lt;&lt; endl;1152 &#125;11531154 &#125;1155 break;11561157 case BR_DEAD_BINDER://收到binder驱动发来的service死掉的消息1158 &#123;1159 BpBinder *proxy = (BpBinder*)mIn.readPointer();1160 proxy-&gt;sendObituary();1161 mOut.writeInt32(BC_DEAD_BINDER_DONE);1162 mOut.writePointer((uintptr_t)proxy);1163 &#125; break;1177 ...1178 case BR_SPAWN_LOOPER:1179 mProcess-&gt;spawnPooledThread(false);1180 break;11811182 default:1183 ALOGE("*** BAD COMMAND %d received from Binder driver\n", cmd);1184 result = UNKNOWN_ERROR;1185 break;1186 &#125;11871188 if (result != NO_ERROR) &#123;1189 mLastError = result;1190 &#125;11911192 return result;1193&#125; 总结一下： 上面MediaPlayerService::instantiate();大概执行的是通过ioctl与Binder通信，Binder通过handle通知到ServiceManager 再来看下线程池的内容startThreadPool 123456789void ProcessState::startThreadPool()158&#123;159 AutoMutex _l(mLock);160 if (!mThreadPoolStarted) &#123;161 mThreadPoolStarted = true;162 spawnPooledThread(true);163 &#125;164&#125; 12345678910void ProcessState::spawnPooledThread(bool isMain)353&#123;354 if (mThreadPoolStarted) &#123;355 String8 name = makeBinderThreadName();356 ALOGV("Spawning new pooled thread, name=%s\n", name.string());357 sp&lt;Thread&gt; t = new PoolThread(isMain);358 t-&gt;run(name.string());359 &#125;360&#125; 再来看下PoolThread函数 123456789101112131415161718class PoolThread : public Thread51&#123;52public:53 explicit PoolThread(bool isMain)54 : mIsMain(isMain)55 &#123;56 &#125;5758protected:59 virtual bool threadLoop()60 &#123;61 IPCThreadState::self()-&gt;joinThreadPool(mIsMain);62 return false;63 &#125;6465 const bool mIsMain;66&#125;; 又回到了joinThreadPool 1234567891011121314151617181920212223242526272829303132void IPCThreadState::joinThreadPool(bool isMain)529&#123;530 LOG_THREADPOOL("**** THREAD %p (PID %d) IS JOINING THE THREAD POOL\n", (void*)pthread_self(), getpid());531532 mOut.writeInt32(isMain ? BC_ENTER_LOOPER : BC_REGISTER_LOOPER);533534 status_t result;535 do &#123;536 processPendingDerefs();537 // now get the next command to be processed, waiting if necessary538 result = getAndExecuteCommand(); //这个方法中执行了result = talkWithDriver();539540 if (result &lt; NO_ERROR &amp;&amp; result != TIMED_OUT &amp;&amp; result != -ECONNREFUSED &amp;&amp; result != -EBADF) &#123;541 ALOGE("getAndExecuteCommand(fd=%d) returned unexpected error %d, aborting",542 mProcess-&gt;mDriverFD, result);543 abort();544 &#125;545546 // Let this thread exit the thread pool if it is no longer547 // needed and it is not the main process thread.548 if(result == TIMED_OUT &amp;&amp; !isMain) &#123;549 break;550 &#125;551 &#125; while (result != -ECONNREFUSED &amp;&amp; result != -EBADF);552553 LOG_THREADPOOL("**** THREAD %p (PID %d) IS LEAVING THE THREAD POOL err=%d\n",554 (void*)pthread_self(), getpid(), result);555556 mOut.writeInt32(BC_EXIT_LOOPER);557 talkWithDriver(false);558&#125; 这个子线程还是通过talkWithDriver，也就是ioctl与binder想建立通信，所以看得出mediaPlayerService除了自己主线程joinThreadPool读取binder设备外，还通过startThreadPool新启动了一个线程读取Binder设备。 Binder是通信机制，BpBinder,BpServiceManager…这些是业务，要把这些区分开，才便于理解，Binder之所以难于理解，就在于层层封装，巧妙的把通信与业务融合在一起。 上面提到，defaultServiceManager()实际上像是初始化了BpServiceManager对象，以及建立了以BpBinder作为通信参数的通道。传递的handle为0，表示的是ServiceManager。 那么来看下ServiceManager是如何处理请求的。service_manager.c的源代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758int main(int argc, char** argv)&#123; struct binder_state *bs; union selinux_callback cb; char *driver; if (argc &gt; 1) &#123; driver = argv[1]; &#125; else &#123; driver = "/dev/binder"; &#125; bs = binder_open(driver, 128*1024);//打开binder设备 128k if (!bs) &#123;#ifdef VENDORSERVICEMANAGER ALOGW("failed to open binder driver %s\n", driver); while (true) &#123; sleep(UINT_MAX); &#125;#else ALOGE("failed to open binder driver %s\n", driver);#endif return -1; &#125; if (binder_become_context_manager(bs)) &#123; //成为manager ALOGE("cannot become context manager (%s)\n", strerror(errno)); return -1; &#125; cb.func_audit = audit_callback; selinux_set_callback(SELINUX_CB_AUDIT, cb); cb.func_log = selinux_log_callback; selinux_set_callback(SELINUX_CB_LOG, cb);#ifdef VENDORSERVICEMANAGER sehandle = selinux_android_vendor_service_context_handle();#else sehandle = selinux_android_service_context_handle();#endif selinux_status_open(true); if (sehandle == NULL) &#123; ALOGE("SELinux: Failed to acquire sehandle. Aborting.\n"); abort(); &#125; if (getcon(&amp;service_manager_context) != 0) &#123; ALOGE("SELinux: Failed to acquire service_manager context. Aborting.\n"); abort(); &#125; binder_loop(bs, svcmgr_handler);//开启一个loop，执行客户端请求 return 0;&#125; binder_open()方法要看看 12345678910111213141516171819202122232425262728293031323334353637383940414243struct binder_state *binder_open(const char* driver, size_t mapsize)&#123; struct binder_state *bs; struct binder_version vers; bs = malloc(sizeof(*bs)); if (!bs) &#123; errno = ENOMEM; return NULL; &#125; bs-&gt;fd = open(driver, O_RDWR | O_CLOEXEC);//打开binder设备 if (bs-&gt;fd &lt; 0) &#123; fprintf(stderr,"binder: cannot open %s (%s)\n", driver, strerror(errno)); goto fail_open; &#125; if ((ioctl(bs-&gt;fd, BINDER_VERSION, &amp;vers) == -1) || (vers.protocol_version != BINDER_CURRENT_PROTOCOL_VERSION)) &#123; fprintf(stderr, "binder: kernel driver version (%d) differs from user space version (%d)\n", vers.protocol_version, BINDER_CURRENT_PROTOCOL_VERSION); goto fail_open; &#125; bs-&gt;mapsize = mapsize; bs-&gt;mapped = mmap(NULL, mapsize, PROT_READ, MAP_PRIVATE, bs-&gt;fd, 0);//内存映射 if (bs-&gt;mapped == MAP_FAILED) &#123; fprintf(stderr,"binder: cannot map device (%s)\n", strerror(errno)); goto fail_map; &#125; return bs;fail_map: close(bs-&gt;fd);fail_open: free(bs); return NULL;&#125; binder_become_context_manager(bs)也要看看 12345int binder_become_context_manager(struct binder_state *bs)&#123; return ioctl(bs-&gt;fd, BINDER_SET_CONTEXT_MGR, 0);//直接调用ioctl与binder驱动通信&#125; 最后还在看看binder_loop(bs, svcmgr_handler); 12345678910111213141516171819202122232425262728293031323334353637void binder_loop(struct binder_state *bs, binder_handler func)&#123; int res; struct binder_write_read bwr; uint32_t readbuf[32]; bwr.write_size = 0; bwr.write_consumed = 0; bwr.write_buffer = 0; readbuf[0] = BC_ENTER_LOOPER; binder_write(bs, readbuf, sizeof(uint32_t)); for (;;) &#123; //开启循环 bwr.read_size = sizeof(readbuf); bwr.read_consumed = 0; bwr.read_buffer = (uintptr_t) readbuf; res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr); if (res &lt; 0) &#123; ALOGE("binder_loop: ioctl failed (%s)\n", strerror(errno)); break; &#125; res = binder_parse(bs, 0, (uintptr_t) readbuf, bwr.read_consumed, func); //收到请求交给binder_parse去处理, func是一个函数指针 if (res == 0) &#123; ALOGE("binder_loop: unexpected reply?!\n"); break; &#125; if (res &lt; 0) &#123; ALOGE("binder_loop: io error %d %s\n", res, strerror(errno)); break; &#125; &#125;&#125; 继续看binder_parse(bs, 0, (uintptr_t) readbuf, bwr.read_consumed, func)方法 123456789101112131415161718192021222324int binder_parse(struct binder_state *bs, struct binder_io *bio, uintptr_t ptr, size_t size, binder_handler func)&#123; ... binder_dump_txn(txn); if (func) &#123; unsigned rdata[256/4]; struct binder_io msg; struct binder_io reply; int res; bio_init(&amp;reply, rdata, sizeof(rdata), 4); bio_init_from_txn(&amp;msg, txn); res = func(bs, txn, &amp;msg, &amp;reply); if (txn-&gt;flags &amp; TF_ONE_WAY) &#123; binder_free_buffer(bs, txn-&gt;data.ptr.buffer); &#125; else &#123; binder_send_reply(bs, &amp;reply, txn-&gt;data.ptr.buffer, res); &#125; &#125; ... return r;&#125; 最终交给的是func来处理，func是一个函数指针，从main()方法中传递的是svcmgr_handler 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110int svcmgr_handler(struct binder_state *bs, struct binder_transaction_data *txn, struct binder_io *msg, struct binder_io *reply)&#123; struct svcinfo *si; uint16_t *s; size_t len; uint32_t handle; uint32_t strict_policy; int allow_isolated; uint32_t dumpsys_priority; //ALOGI("target=%p code=%d pid=%d uid=%d\n", // (void*) txn-&gt;target.ptr, txn-&gt;code, txn-&gt;sender_pid, txn-&gt;sender_euid); if (txn-&gt;target.ptr != BINDER_SERVICE_MANAGER) return -1; if (txn-&gt;code == PING_TRANSACTION) return 0; // Equivalent to Parcel::enforceInterface(), reading the RPC // header with the strict mode policy mask and the interface name. // Note that we ignore the strict_policy and don't propagate it // further (since we do no outbound RPCs anyway). strict_policy = bio_get_uint32(msg); s = bio_get_string16(msg, &amp;len); if (s == NULL) &#123; return -1; &#125; if ((len != (sizeof(svcmgr_id) / 2)) || memcmp(svcmgr_id, s, sizeof(svcmgr_id))) &#123; fprintf(stderr,"invalid id %s\n", str8(s, len)); return -1; &#125; if (sehandle &amp;&amp; selinux_status_updated() &gt; 0) &#123;#ifdef VENDORSERVICEMANAGER struct selabel_handle *tmp_sehandle = selinux_android_vendor_service_context_handle();#else struct selabel_handle *tmp_sehandle = selinux_android_service_context_handle();#endif if (tmp_sehandle) &#123; selabel_close(sehandle); sehandle = tmp_sehandle; &#125; &#125; switch(txn-&gt;code) &#123; case SVC_MGR_GET_SERVICE: case SVC_MGR_CHECK_SERVICE: s = bio_get_string16(msg, &amp;len); if (s == NULL) &#123; return -1; &#125; handle = do_find_service(s, len, txn-&gt;sender_euid, txn-&gt;sender_pid); if (!handle) break; bio_put_ref(reply, handle); return 0; case SVC_MGR_ADD_SERVICE: s = bio_get_string16(msg, &amp;len); if (s == NULL) &#123; return -1; &#125; handle = bio_get_ref(msg); allow_isolated = bio_get_uint32(msg) ? 1 : 0; dumpsys_priority = bio_get_uint32(msg); if (do_add_service(bs, s, len, handle, txn-&gt;sender_euid, allow_isolated, dumpsys_priority, txn-&gt;sender_pid)) //处理addService的请求 return -1; break; case SVC_MGR_LIST_SERVICES: &#123;//当前系统所有已注册的service的名字 uint32_t n = bio_get_uint32(msg); uint32_t req_dumpsys_priority = bio_get_uint32(msg); if (!svc_can_list(txn-&gt;sender_pid, txn-&gt;sender_euid)) &#123; ALOGE("list_service() uid=%d - PERMISSION DENIED\n", txn-&gt;sender_euid); return -1; &#125; si = svclist; // walk through the list of services n times skipping services that // do not support the requested priority while (si) &#123; if (si-&gt;dumpsys_priority &amp; req_dumpsys_priority) &#123; if (n == 0) break; n--; &#125; si = si-&gt;next; &#125; if (si) &#123; bio_put_string16(reply, si-&gt;name); return 0; &#125; return -1; &#125; default: ALOGE("unknown code %d\n", txn-&gt;code); return -1; &#125; bio_put_uint32(reply, 0); return 0;&#125; 来看下do_add_service(bs, s, len, handle, txn-&gt;sender_euid, allow_isolated, dumpsys_priority,txn-&gt;sender_pid)的请求 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748int do_add_service(struct binder_state *bs, const uint16_t *s, size_t len, uint32_t handle, uid_t uid, int allow_isolated, uint32_t dumpsys_priority, pid_t spid) &#123; struct svcinfo *si; //ALOGI("add_service('%s',%x,%s) uid=%d\n", str8(s, len), handle, // allow_isolated ? "allow_isolated" : "!allow_isolated", uid); if (!handle || (len == 0) || (len &gt; 127)) return -1; if (!svc_can_register(s, len, spid, uid)) &#123; //判断注册的服务的进程是否有权限，有兴趣的可以看看这个方法 ALOGE("add_service('%s',%x) uid=%d - PERMISSION DENIED\n", str8(s, len), handle, uid); return -1; &#125; si = find_svc(s, len); if (si) &#123; if (si-&gt;handle) &#123; ALOGE("add_service('%s',%x) uid=%d - ALREADY REGISTERED, OVERRIDE\n", str8(s, len), handle, uid); svcinfo_death(bs, si); &#125; si-&gt;handle = handle; &#125; else &#123; si = malloc(sizeof(*si) + (len + 1) * sizeof(uint16_t)); if (!si) &#123; ALOGE("add_service('%s',%x) uid=%d - OUT OF MEMORY\n", str8(s, len), handle, uid); return -1; &#125; si-&gt;handle = handle; si-&gt;len = len; memcpy(si-&gt;name, s, (len + 1) * sizeof(uint16_t)); si-&gt;name[len] = '\0'; si-&gt;death.func = (void*) svcinfo_death; si-&gt;death.ptr = si; si-&gt;allow_isolated = allow_isolated; si-&gt;dumpsys_priority = dumpsys_priority; si-&gt;next = svclist;//保存当前注册到ServiceManager中到信息 svclist = si; &#125; binder_acquire(bs, handle); binder_link_to_death(bs, handle, &amp;si-&gt;death);//退出清理工作 return 0;&#125; 还是简单看看svc_can_register(s, len, spid, uid)这个方法把 1234567891011static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid, uid_t uid)&#123; const char *perm = "add"; if (multiuser_get_app_id(uid) &gt;= AID_APP) &#123; return 0; /* Don't allow apps to register services */ &#125; return check_mac_perms_from_lookup(spid, uid, perm, str8(name, name_len)) ? 1 : 0;&#125; 总结：从上面来看，ServiceManger打开了binder设备，通过ioctl与binder驱动通信，保存了addService信息。 集中管理系统内到所有到服务，施加权限控制。 ServiceManager支持通过字符串来查找对应到Service。 Client只需要通过查询ServiceManager，就可以知道对应到Server是否存活与通信，这个非常的方便。 上面分析了ServiceManager和他的client，接下来从业务的角度来看，MediaPlayerService通信层如何与client端交互的。 一个client想得到某个Service的信息，就必须与ServiceManager打交道，通过getService方法来获取Service信息，来看下IMediaDeathNotifier::getMediaPlayerService()的源码 1234567891011121314151617181920212223242526IMediaDeathNotifier::getMediaPlayerService()&#123; ALOGV("getMediaPlayerService"); Mutex::Autolock _l(sServiceLock); if (sMediaPlayerService == 0) &#123; sp&lt;IServiceManager&gt; sm = defaultServiceManager(); sp&lt;IBinder&gt; binder; do &#123; binder = sm-&gt;getService(String16("media.player")); //之前注册的服务的name if (binder != 0) &#123; break; &#125; ALOGW("Media player service not published, waiting..."); usleep(500000); // 0.5 s &#125; while (true); if (sDeathNotifier == NULL) &#123; sDeathNotifier = new DeathNotifier(); &#125; binder-&gt;linkToDeath(sDeathNotifier); sMediaPlayerService = interface_cast&lt;IMediaPlayerService&gt;(binder);//interface_cast将这个binder转成[BpMediaPlayerService](http://www.androidos.net.cn/android/9.0.0_r8/xref/frameworks/av/media/libmedia/IMediaPlayerService.cpp) &#125; ALOGE_IF(sMediaPlayerService == 0, "no media player service!?"); return sMediaPlayerService;&#125; 有了BpMediaPlayerService,就能够使用任何IMediaPlayerService提供的业务函数，像createMediaRecorder,createMetadataRetriever等。这些方法都调用了remote()-&gt;transact()，把数据打包交给了binder驱动，说明都是调用了BpBinder，通过对应都handle找到对应都客户端。 上面都分析中，MediaPlayerService在MediaServer进程中，这个进程有两个线程在talkWithDriver。假设其中一个线程收到消息时，最终会调用executeCommand()方法 1234567891011121314151617181920212223242526272829303132333435status_t IPCThreadState::executeCommand(int32_t cmd)&#123; BBinder* obj; RefBase::weakref_type* refs; status_t result = NO_ERROR; switch ((uint32_t)cmd) &#123; ... case BR_TRANSACTION: &#123; ... if (tr.target.ptr) &#123; // We only have a weak reference on the target object, so we must first try to // safely acquire a strong reference before doing anything else with it. if (reinterpret_cast&lt;RefBase::weakref_type*&gt;( tr.target.ptr)-&gt;attemptIncStrong(this)) &#123; error = reinterpret_cast&lt;BBinder*&gt;(tr.cookie)-&gt;transact(tr.code, buffer, &amp;reply, tr.flags); reinterpret_cast&lt;BBinder*&gt;(tr.cookie)-&gt;decStrong(this);//BBinder,实际上实现的是BnServiceXXX对象 &#125; else &#123; error = UNKNOWN_TRANSACTION; &#125; &#125; else &#123; error = the_context_object-&gt;transact(tr.code, buffer, &amp;reply, tr.flags); &#125; ... &#125; break; &#125; return result;&#125; 从类图关系中可以看出，BnMediaPlayerService实现了onTransact()方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162status_t BnMediaPlayerService::onTransact( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)&#123; switch (code) &#123; case CREATE: &#123; CHECK_INTERFACE(IMediaPlayerService, data, reply); sp&lt;IMediaPlayerClient&gt; client = interface_cast&lt;IMediaPlayerClient&gt;(data.readStrongBinder()); audio_session_t audioSessionId = (audio_session_t) data.readInt32(); sp&lt;IMediaPlayer&gt; player = create(client, audioSessionId); reply-&gt;writeStrongBinder(IInterface::asBinder(player)); return NO_ERROR; &#125; break; case CREATE_MEDIA_RECORDER: &#123; CHECK_INTERFACE(IMediaPlayerService, data, reply); const String16 opPackageName = data.readString16(); sp&lt;IMediaRecorder&gt; recorder = createMediaRecorder(opPackageName); reply-&gt;writeStrongBinder(IInterface::asBinder(recorder)); return NO_ERROR; &#125; break; case CREATE_METADATA_RETRIEVER: &#123; CHECK_INTERFACE(IMediaPlayerService, data, reply); sp&lt;IMediaMetadataRetriever&gt; retriever = createMetadataRetriever(); //交给子类来实现 reply-&gt;writeStrongBinder(IInterface::asBinder(retriever)); return NO_ERROR; &#125; break; case ADD_BATTERY_DATA: &#123; CHECK_INTERFACE(IMediaPlayerService, data, reply); uint32_t params = data.readInt32(); addBatteryData(params); return NO_ERROR; &#125; break; case PULL_BATTERY_DATA: &#123; CHECK_INTERFACE(IMediaPlayerService, data, reply); pullBatteryData(reply); return NO_ERROR; &#125; break; case LISTEN_FOR_REMOTE_DISPLAY: &#123; CHECK_INTERFACE(IMediaPlayerService, data, reply); const String16 opPackageName = data.readString16(); sp&lt;IRemoteDisplayClient&gt; client( interface_cast&lt;IRemoteDisplayClient&gt;(data.readStrongBinder())); if (client == NULL) &#123; reply-&gt;writeStrongBinder(NULL); return NO_ERROR; &#125; String8 iface(data.readString8()); sp&lt;IRemoteDisplay&gt; display(listenForRemoteDisplay(opPackageName, client, iface)); reply-&gt;writeStrongBinder(IInterface::asBinder(display)); return NO_ERROR; &#125; break; case GET_CODEC_LIST: &#123; CHECK_INTERFACE(IMediaPlayerService, data, reply); sp&lt;IMediaCodecList&gt; mcl = getCodecList(); reply-&gt;writeStrongBinder(IInterface::asBinder(mcl)); return NO_ERROR; &#125; break; default: return BBinder::onTransact(code, data, reply, flags); &#125;&#125; 看出来了吧，BnServicexxx就是与client通信的业务逻辑 来个demo，纯native实现c/s框架 aidl demo]]></content>
  </entry>
  <entry>
    <title><![CDATA[battery-historian环境搭建与简单分析]]></title>
    <url>%2F2019%2F12%2F03%2Fbattery-historian%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[首先可以参考https://www.jianshu.com/p/c86021fe958d 这篇博客 大概需要安装以下环境: go,和配置go环境 docker环境 java python(小于版本3) 按照https://github.com/google/battery-historian 的提示一步一步操作 当执行go run setup.go 报错的话，执行下面这段命令 12345cd third_party/closure-library/git reset --hard v20170409cd -go run setup.go 最后运行以下命令来运行打开本地的服务 123456# lewis @ Mac-mini-2 in ~ [15:58:25] C:125$ docker run -p 9000:9999 registry.cn-hangzhou.aliyuncs.com/xyz10/android-battery-historian:stable-3.02019/11/29 08:00:23 Listening on port: 99992019/11/29 08:00:48 Trace starting analysisServer processing for: GET2019/11/29 08:00:48 Trace finished analysisServer processing for: GET 网页浏览 http://localhost:9000/ 打开，有上传文件的按钮，却找不到提交的按钮。 解决方法： 审查元素，修改xml代码把下面这行 style=”display:none改为 style=”display:show。submit按钮就会出现了。 12&lt;input id="upload-submit" type="submit" name="submit" value="Submit" class="btn btn-primary btn-submit" style="display:none"&gt; 但是这种上传zip或者txt无法分析表格，只有数据。一直google都无法解决。 按照github的操作仔细检查一遍，发现下面这步无法通过，分析一下 123456# lewis @ Mac-mini-2 in ~/go/src/github.com/google/battery-historian on git:master x [10:31:37] $ docker run -p 9998:9998 gcr.io/android-battery-historian/stable:3.0 --port 9998Unable to find image 'gcr.io/android-battery-historian/stable:3.0' locallydocker: Error response from daemon: Get https://gcr.io/v2/: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers).See 'docker run --help'. 通过代理，翻墙，各种设置还是没pull下来。。。 转换思路，为什么上面第二点可以打开localhost, 于是搜索registry.cn-hangzhou.aliyuncs.com， 参考了下https://juejin.im/entry/5d61fc3ff265da038f4818a5 这篇博客，调用了以下命令，居然可以监听了，上传文件后，submit的按钮自动出来了，分析还会出现进度条，最后果然是成功出现了分析图。 1234567891011121314151617# lewis @ Mac-mini-2 in ~/go/src/github.com/google/battery-historian on git:master x [11:58:32] C:1$ go run cmd/battery-historian/battery-historian.go --port 90002019/12/03 11:59:12 Listening on port: 90002019/12/03 11:59:18 Trace starting analysisServer processing for: GET2019/12/03 11:59:18 Trace finished analysisServer processing for: GET2019/12/03 11:59:26 Trace starting analysisServer processing for: GET2019/12/03 11:59:26 Trace finished analysisServer processing for: GET2019/12/03 11:59:36 Trace starting analysisServer processing for: POST2019/12/03 11:59:36 Trace starting reading uploaded file. 2093015 bytes2019/12/03 11:59:37 Trace started analyzing "bugreport.zip~bugreport-EVA-AL00-HUAWEIEVA-AL00-2019-12-02-15-40-47.txt" file.2019/12/03 11:59:38 Trace finished processing checkin.2019/12/03 11:59:38 Trace finished generating Historian plot.2019/12/03 11:59:38 Trace finished processing summary data.2019/12/03 11:59:38 Trace finished analyzing "bugreport.zip~bugreport-EVA-AL00-HUAWEIEVA-AL00-2019-12-02-15-40-47.txt" file.2019/12/03 11:59:38 Trace ended analyzing file.2019/12/03 11:59:38 Trace finished analysisServer processing for: POST 对参数的分析，可以访问此链接https://www.jianshu.com/p/a704e2268fe6 ，这些其他朋友都各自有分析过，这就不在重复复制了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[音频解码流程分析]]></title>
    <url>%2F2019%2F08%2F27%2F%E9%9F%B3%E9%A2%91%E8%A7%A3%E7%A0%81%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[音频解码流程分析 OpenSLES初始化 -&gt; 初始化音频引擎 -&gt; 子线程解码原始数据到SafeQueue&lt;AVPacket *&gt;队列中 -&gt; 解码器返回解码到输出数据到SafeQueue&lt;AVFrame *&gt; frame_queue 队列 -&gt; 转换音频 -&gt; 引擎播放 音频的解码流程与视频很相似。都是操作原始数据先到packet线程，再被压到frame队列。不同的是，audio解码后用到的是opensles来播放，因此开启来一个线程来处理初始化工作。 opensles的学习可以参考google-sample/sdk的例子:https://github.com/googlesamples/android-ndk/tree/master/native-audio 先来看下opensles初始化的方法: 配置播放pcm格式的数据 设置缓存队列，把解压的数据回调到播放器中播放 貌似没有什么好讲的，可以查看项目代码注释或者查看google官方例子 decode解码 SafeQueue&lt;AVPacket *&gt; pkt_queue取数据，通过avcodec_send_packet方法解码，此方法再视频解码解释过了。 avcodec_receive_frame()获得解码数据，并根据当前frame_queue队列的情况判断是否压入队列。 getPcm取frame队列中的数据转换音频，通过转换回调给播放器 1234567891011121314151617181920/** Convert audio. * * in and in_count can be set to 0 to flush the last few samples out at the * end. * * If more input is provided than output space, then the input will be buffered. * You can avoid this buffering by using swr_get_out_samples() to retrieve an * upper bound on the required number of output samples for the given number of * input samples. Conversion will run directly without copying whenever possible. * * @param s allocated Swr context, with parameters set * @param out output buffers, only the first one need be set in case of packed audio * @param out_count amount of space available for output in samples per channel * @param in input buffers, only the first one need to be set in case of packed audio * @param in_count number of input samples available in one channel * * @return number of samples output per channel, negative value on error */int swr_convert(struct SwrContext *s, uint8_t **out, int out_count, const uint8_t **in , int in_count); 项目链接地址： https://github.com/lgq895767507/QuickPlay]]></content>
  </entry>
  <entry>
    <title><![CDATA[解压视频及同步音频流程分析]]></title>
    <url>%2F2019%2F08%2F27%2F%E8%A7%86%E9%A2%91%E8%A7%A3%E7%A0%81%E4%B8%8E%E5%90%8C%E6%AD%A5%E9%9F%B3%E9%A2%91%2F</url>
    <content type="text"><![CDATA[解压视频及同步音频流程分析 数据 -&gt; 子线程解码原始数据到SafeQueue&lt;AVPacket *&gt;队列中 -&gt; 解码器返回解码到输出数据到SafeQueue&lt;AVFrame *&gt; frame_queue 队列 -&gt; 取切片数据dst_data返回给窗口window -&gt; 比较当前视频时间戳与当前帧音频时间戳 -&gt; 处理视频延时或者追赶处理 -&gt; 达到音视频同步 开始之前先掌握以下几个概念 音视频同步是以音频时间为准，通过减缓视频渲染或者丢帧加快视频渲染的操作来达到同步，但同步不是绝对的，是相对的同步，即相差的时间非常短。 需要两个子线程来处理工作，一个packet线程用来解码，一个frame线程用来同步渲染视频 把AVPacket数据解码需要用到这个方法avcodec_send_packet 1234567//avcodec.h/** * Supply raw packet data as input to a decoder. * ... * /int avcodec_send_packet(AVCodecContext *avctx, const AVPacket *avpkt); 从解码器返回输出到数据给到AVFrame结构体队列中,frame_queue.enQueue(frame); 1234567/** * Return decoded output data from a decoder. * ... * / int avcodec_receive_frame(AVCodecContext *avctx, AVFrame *frame); sws_scale方法, 获得切片数据dst[], 和slice宽高 12345678910/** * Scale the image slice in srcSlice and put the resulting scaled * slice in the image in dst. A slice is a sequence of consecutive * rows in an image. * ... */int sws_scale(struct SwsContext *c, const uint8_t *const srcSlice[], const int srcStride[], int srcSliceY, int srcSliceH, uint8_t *const dst[], const int dstStride[]); av_q2d方法 12345678910/** * Convert an AVRational to a `double`. * @param a AVRational to convert * @return `a` in floating-point form * @see av_d2q() */static inline double av_q2d(AVRational a)&#123; return a.num / (double) a.den;&#125; 项目链接地址： https://github.com/lgq895767507/QuickPlay]]></content>
  </entry>
  <entry>
    <title><![CDATA[Context上下文简述]]></title>
    <url>%2F2019%2F08%2F15%2FContext%2F</url>
    <content type="text"><![CDATA[Context是一个抽象类,activity,service,application都是其子类,因此一个应用程序中 Context 的数量等于 Activity 和 Service 的数量加1。 Context的主要功能为: 1)启动Activity2）启动和停止Service3）发送广播消息(Intent)4）注册广播消息(Intent)接收者5）可以访问APK中各种资源(如Resources和AssetManager等)6）可以访问Package的相关信息7）APK的各种权限管理 返回当前进程的单实例全局Application对象的Context,指向的是Context public abstract Context getApplicationContext(); 返回由构造函数指定或setBaseContext()设置的上下文。 1234567 /** * @return the base context as set by the constructor or setBaseContext */ public Context getBaseContext() &#123; return mBase; &#125; getApplication()只能在Activity和Service里使用，指向的是Application对象 12345/** Return the application that owns this activity. */ public final Application getApplication() &#123; return mApplication; &#125; 很重要的一点，activity的context对象在activity销毁的时候，context也会跟着销毁,所以持有activity对象没有及时销毁可能造成内存泄漏。 解决方案就是使用applicationContext代替activity的context Intent也要求指出上下文，如果是activity的上下文就会把启动的activity关联当前的activity，如果是application的context，那么启动就需要添加Intent.FLAG_ACTIVITY_NEW_TASK标志，否则会报错。相当于重新创建了一个新的栈。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android View的加载与绘制源码分析]]></title>
    <url>%2F2019%2F08%2F05%2FView%E7%9A%84%E5%8A%A0%E8%BD%BD%E4%B8%8E%E7%BB%98%E5%88%B6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[（一）Android View的加载源码分析 view是如果被加载到界面上的？创建一个普通的activity 123456789101112131415161718192021222324//1.MainActivity.javapublic class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //添加布局入口 setContentView(R.layout.activity_main); &#125;&#125;//2.Activity.javapublic void setContentView(@LayoutRes int layoutResID) &#123; getWindow().setContentView(layoutResID); initWindowDecorActionBar(); &#125;//getWindow()获取的window对象是mWindow，Window类是个抽象类，拥有唯一的实例android.view.PhoneWindow/* &lt;p&gt;The only existing implementation of this abstract class is android.view.PhoneWindow, which you should instantiate when needing a Window. */ public abstract class Window &#123; ... &#125; PhoneWindow.java文件 1234567891011121314151617181920212223242526272829303132//3.PhoneWindow.java//因此到PhoneWindow找到setContentView(int layoutResID)@Override public void setContentView(int layoutResID) &#123; // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window // decor, when theme attributes and the like are crystalized. Do not check the feature // before this happens. if (mContentParent == null) &#123; installDecor(); &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; mContentParent.removeAllViews(); &#125; if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID, getContext()); transitionTo(newScene); &#125; else &#123; mLayoutInflater.inflate(layoutResID, mContentParent); &#125; mContentParent.requestApplyInsets(); final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) &#123; cb.onContentChanged(); &#125; &#125;//4. installDecor(); //5. mLayoutInflater.inflate(layoutResID, mContentParent);//解析传进来的layoutResID和mContentParent， 实际上就是把传进来的mContentParent加载到mContentParent上，mContentParent是一个frameLayout 12345678910111213141516//4. installDecor();//4.1创建DevorView mDecor = generateDecor(); //4.2创建mContentParent mContentParent = generateLayout(mDecor); //4.2创建mContentParent//解析基础控件layoutResourceView in = mLayoutInflater.inflate(layoutResource, null);//DecorView添加基础控件indecor.addView(in, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));mContentRoot = (ViewGroup) in;//添加ID_ANDROID_CONTENT 并且直接返回contentParentViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT); 1234567891011121314151617181920212223242526272829303132// layoutResource是一个基础控件ViewGroup//xref: /frameworks/base/core/res/res/layout/screen_title.xml&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"23 android:orientation="vertical"24 android:fitsSystemWindows="true"&gt;25 &lt;!-- Popout bar for action modes --&gt;26 &lt;ViewStub android:id="@+id/action_mode_bar_stub"27 android:inflatedId="@+id/action_mode_bar"28 android:layout="@layout/action_mode_bar"29 android:layout_width="match_parent"30 android:layout_height="wrap_content"31 android:theme="?attr/actionBarTheme" /&gt;32 &lt;FrameLayout33 android:layout_width="match_parent" 34 android:layout_height="?android:attr/windowTitleSize"35 style="?android:attr/windowTitleBackgroundStyle"&gt;36 &lt;TextView android:id="@android:id/title" 37 style="?android:attr/windowTitleStyle"38 android:background="@null"39 android:fadingEdge="horizontal"40 android:gravity="center_vertical"41 android:layout_width="match_parent"42 android:layout_height="match_parent" /&gt;43 &lt;/FrameLayout&gt;44 &lt;FrameLayout android:id="@android:id/content"45 android:layout_width="match_parent" 46 android:layout_height="0dip"47 android:layout_weight="1"48 android:foregroundGravity="fill_horizontal|top"49 android:foreground="?android:attr/windowContentOverlay" /&gt;50&lt;/LinearLayout&gt; View就这样被加载到界面上了 总结：* 创建顶层布局容器DecorView * 在顶层布局中添加基础布局ViewGroup * 将contentView添加到基础布局容器的FrameLayout中(二) Android View绘制源码分析 view是如何绘制的？ ActivityThread.class 123456789101112131415public void handleMessage(Message msg) &#123; if (DEBUG_MESSAGES) Slog.v(TAG, "&gt;&gt;&gt; handling: " + codeToString(msg.what)); switch (msg.what) &#123; case LAUNCH_ACTIVITY: &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "activityStart"); final ActivityClientRecord r = (ActivityClientRecord) msg.obj; r.packageInfo = getPackageInfoNoCheck( r.activityInfo.applicationInfo, r.compatInfo); handleLaunchActivity(r, null); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); &#125; break; ...&#125; 2.handleLaunchActivity 3.handleResumeActivity 4.wm.addView(decor, l); 12345678910111213141516171819// 4.wm.addView(decor, l); ViewManager wm = a.getWindowManager(); -&gt; mWindowManager = mWindow.getWindowManager(); //mWindow唯一的实例是 PhoneWindow，因此 -&gt; mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this); //因此wm是WindowManagerImpl的实例,在addView中调用了mGlobal.addView（） -&gt; mGlobal.addView(view, params, mDisplay, mParentWindow); //ViewRootImpl关联view, params, panelParentView,root是ViewRootImpl实例化对象 -&gt; root.setView(view, wparams, panelParentView); -&gt; requestLayout() -&gt; checkThread(); -&gt; scheduleTraversals(); -&gt; TraversalRunnable&#123;&#125; -&gt; doTraversal(); -&gt; performTraversals(); -&gt; performMeasure(childWidthMeasureSpec,childHeightMeasureSpec); //1890 测量 -&gt; performLayout(lp, desiredWindowWidth, desiredWindowHeight); //1931 布局 -&gt; performDraw(); // 2067 绘制 view的绘制流程就是以上这些步骤，现在具体来看下performMeasure(),performLayout(),performDraw()这三步关键的步骤。 测量：performMeasure() 先引入一个概念MeasureSpec，view的测量规格，是一个32位的二进制整数类型。view的测量按照一定的规则，以下是MeasureSpec的一些规则： 123456789101112131415161718192021222324//MeasureSpec.java public static int makeMeasureSpec(int size, int mode) &#123; if (sUseBrokenMakeMeasureSpec) &#123; return size + mode; &#125; else &#123; return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK); &#125; &#125;UNSPECIFIED: 00 0000 0000 0000 0000 0000 0000 0000 00-&gt; 父容器不对view做任何限制，系统内部使用 EXACTLY: 01 0000 0000 0000 0000 0000 0000 0000 00-&gt; 父容器检测view的大小，view的大小就是SpecSize ，对应子控件的 LayoutParams.match_parent / 固定大小 AT_MOST: 10 0000 0000 0000 0000 0000 0000 0000 00-&gt; 父容器指定一个可用大小，view不能超过这个值， LayoutParams.wrap_contentMODE_MASK = 11 0000 0000 0000 0000 0000 0000 0000 00 ~MODE_MASK = 00 1111 1111 1111 1111 1111 1111 1111 11 size &amp; ~MODE_MASK = 00 后三十位 model &amp; MODE_MASK = 前两位 0000 0000 0000 0000 0000 0000 0000 00(size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK); == model(前两位) size(后三十位) 继续回到 ViewRootImpl 的1890行 performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); 1234567891011121314151617-&gt; performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);-&gt; mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);-&gt; onMeasure(widthMeasureSpec, heightMeasureSpec);-&gt; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)); //保存自身的宽和高-&gt; setMeasuredDimensionRaw(measuredWidth, measuredHeight);//此处即测量结束，赋值给宽高，并设置标记flagsprivate void setMeasuredDimensionRaw(int measuredWidth, int measuredHeight) &#123; mMeasuredWidth = measuredWidth; mMeasuredHeight = measuredHeight; mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET; &#125;//以上来看view的测量就结束了。但是view是如何测量的，就需要了解传进来的参数childWidthMeasureSpec，childHeightMeasureSpec是怎么得来的 int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width); //1854 ViewRootImpl.java 1234567891011121314151617//mWidth ： 窗口容器的宽度//lp.width: 顶层容器的宽度getRootMeasureSpec(mWidth, lp.width)// 因此 DecorView的MeasureSpec由窗口大小和自身LayoutParams决定，遵守以下规则：// LayoutParams.MATCH_PARENT: 精确模式，窗口大小// LayoutParams.WRAP_CONTENT: 最大模式，最大为窗口大小// 固定大小：精确模式，大小为LayoutParams的大小//实际上是调用DecorView的measure()方法 mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); //在view的measure()方法内部还调用了 onMeasure(widthMeasureSpec, heightMeasureSpec); //DecorView的父类是FrameLayout,在FrameLayout的onMeasure中调用了 child.measure(childWidthMeasureSpec, childHeightMeasureSpec);//因为是容器viewGroup，所以测量了自身需要在测量child控件 总结： viewGroup : measure -&gt; onMeasure(子控件的宽高) -&gt; setMeasuredDimension() -&gt; setMeasuredDimensionRaw(保存自己的宽高)view : measure -&gt; onMeasure() -&gt; setMeasuredDimension() -&gt; setMeasuredDimensionRaw(保存自己的宽高)自定义view不重写onMeasure方法，使用match_parent 和 wrap_content的效果是一样的 布局performLayout() ,回到performLayout(lp, desiredWindowWidth, desiredWindowHeight); //1931 ViewRootImpl.java 123456-&gt; host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight());-&gt; setFrame(l, t, r, b);//调用view.layout确定自身的位置，即确定mLeft,mTop,mRight,mBottom的值 总结：viewGroup: layout(确定自己的位置，4个点的位置)-&gt;onLayout(进行子view的布局)view: layout(确定自己的位置，4个点的位置) performDraw绘制 //2067 ViewRootImpl.java 12345678910111213141516-&gt; performDraw()-&gt; draw()-&gt; drawSoftware()-&gt; mView.draw(canvas);-&gt; /* * Draw traversal performs several drawing steps which must be executed * in the appropriate order: * * 1. Draw the background * 2. If necessary, save the canvas' layers to prepare for fading * 3. Draw view's content * 4. Draw children * 5. If necessary, draw the fading edges and restore layers * 6. Draw decorations (scrollbars for instance) */ 总结：viewGroup: 绘制背景drawBackground() 绘制自己onDraw() 绘制子view dispatchDraw() 绘制前景,滚动条等装饰onDrawForeground() view: 绘制背景drawBackground() 绘制自己onDraw() 绘制前景,滚动条等装饰onDrawForeground()]]></content>
  </entry>
  <entry>
    <title><![CDATA[红黑树]]></title>
    <url>%2F2019%2F08%2F05%2F%E7%BA%A2%E9%BB%91%E6%A0%91%2F</url>
    <content type="text"><![CDATA[二叉查找树（BST）定义：一颗二叉树，每个结点都有一个Comparable的键且每个结点的键都大于其左子树的任意结点的键而小于右子树的任意结点的键。 二叉查找树的图像形状 查找 插入 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public class BST&lt;Key extends Comparable&lt;Key&gt;, Value&gt; &#123; private Node root; private class Node &#123; private Key key; //键 private Value val; private Node left, right; //指向子树的链接 private int N; //以该结点为根的子树中的节点总数 public Node(Key key, Value val, int n) &#123; this.key = key; this.val = val; N = n; &#125; &#125; public int size() &#123; return size(root); &#125; private int size(Node x) &#123; if (x == null) &#123; return 0; &#125; else &#123; return x.N; &#125; &#125; //查找 public Value get(Key key) &#123; return get(root, key); &#125; private Value get(Node x, Key key) &#123; if (x == null) return null; int cmp = key.compareTo(x.key); if (cmp &lt; 0) return get(x.left, key); else if (cmp &gt; 0) return get(x.right, key); else return x.val; &#125; //插入 public void put(Key key, Value val) &#123; root = put(root, key, val); &#125; private Node put(Node x, Key key, Value val) &#123; if (x == null) return new Node(key, val, 1); int cmp = key.compareTo(x.key); if (cmp &lt; 0) x.left = put(x.left, key, val); else if (cmp &gt; 0) x.right = put(x.right, key, val); else x.val = val; x.N = size(x.left) + size(x.right) + 1; return x; &#125; //取最小key public Key min() &#123; return min(root).key; &#125; private Node min(Node x) &#123; if (x.left == null) return x; return min(x.left); &#125; //向下取之整 public Key floor(Key key) &#123; Node x = floor(root, key); if (x == null) return null; return x.key; &#125; private Node floor(Node x, Key key) &#123; if (x == null) return null; int cmp = key.compareTo(x.key); if (cmp == 0) return x; if (cmp &lt; 0) return floor(x.left, key); Node t = floor(x.right, key); if (t != null) return t; else return x; &#125; //max() //ceiling()&#125; 二分查找法 性能分析 平衡查找树2-3树定义：一颗2-3树或为空树，或为以下结点组成： 2-结点：含有一个键(及值)和两条链接，左链接指向的2-3树中的键都小于该结点，右链接指向的2-3树中的键都大于该结点。 3-结点：含有两个键(及值)和三条链接，左链接指向的2-3树中的键都小于该结点，中链接指向的2-3树中的键都位于该结点的两个键之间，右链接指向的2-3树中的键都大于该结点。 一颗完美平衡的2-3查找树中的所有空链接到根结点的距离都是相同的。 查找要判断一个键是否在树中，我们先将它和根结点中的键比较。如果它和其中的任何一个相等，查找命中。否则我们就根据比较的结果找到指向相应区间的链接，并在其指向的子树中递归地继续查找。如果这是个空链接，查找未命中。 插入 向2-结点插入新键 只要把这个2-结点替换为一个3-结点，将要插入的键保存在其中即可 向只有3-结点插入新键 创建一个4-结点很方便，因为很容易将它转换为一颗由3个2-结点组成的2-3树 向父节点为2-结点的3-结点插入新键 同上，但是不会为中键创建一个新结点，而是将其移动至原来的父结点中 向父节点为3-结点的3-结点插入新键 一直向上不断分解临时的4-结点并将中键插入更高的父结点，直至遇到一个2-结点并将它替换为一个不需要继续分解的3-结点，或者是到达3-结点的根 性能：一颗大小为N的2-3树，查找和插入操作访问的结点必然不超过logN个。高度在log3 N 与log2 N之间。 红黑二叉查找树一种等价的定义： 红链接均为左链接 没有任何一个结点同时和两条红链接相连 该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同。 红链接：将两个2-结点连接起来构成一个3-结点黑链接：2-3树中的普通链接 示例图 旋转 左旋 右旋 插入 新键最小 新键最大 新键介于中间 变色 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package redblack;public class RedBlackBST&lt;Key extends Comparable&lt;Key&gt;, Value&gt; &#123; private static final boolean RED = true; private static final boolean BLACK = false; private Node root; public void put(Key key, Value val) &#123; root = put(root, key, val); root.color = BLACK; &#125; private Node put(Node h, Key key, Value val) &#123; if (h == null) &#123; return new Node(key, val, 1, RED); &#125; int cmp = key.compareTo(h.key); if (cmp &lt; 0) h.left = put(h.left, key, val); else if (cmp &gt; 0) h.right = put(h.right, key, val); else h.val = val; if (isRed(h.right) &amp;&amp; !isRed(h.left)) h = rotateLeft(h); if (isRed(h.left) &amp;&amp; isRed(h.left.left)) h = rotateRight(h); if (isRed(h.left) &amp;&amp; isRed(h.right)) flipColors(h); h.N = size(h.left) + size(h.right) + 1; return h; &#125; private void flipColors(Node h) &#123; h.color = RED; h.left.color = BLACK; h.right.color = BLACK; &#125; private Node rotateRight(Node h) &#123; Node x = h.left; h.left = x.right; x.right = h; x.color = h.color; h.color = RED; x.N = h.N; h.N = size(h.left) + size(h.right) + 1; return x; &#125; private Node rotateLeft(Node h) &#123; Node x = h.right; h.right = x.left; x.left = h; x.color = h.color; h.color = RED; x.N = h.N; h.N = size(h.left) + size(h.right) + 1; return x; &#125; private boolean isRed(Node x) &#123; if (x == null) return false; else return x.color == RED; &#125; public int size() &#123; return size(root); &#125; private int size(Node x) &#123; if (x == null) &#123; return 0; &#125; else &#123; return x.N; &#125; &#125; private class Node &#123; private Key key; private Value val; private Node left, right; private int N; private boolean color; public Node(Key key, Value val, int n, boolean color) &#123; this.key = key; this.val = val; N = n; this.color = color; &#125; &#125;&#125; 结论：性能: 一颗大小为N的红黑树，根结点到任意结点的平均路径长度为logN。和典型的二叉查找树相比，构造的长度比它低40%左右。 顺序查询（无序链表） 最坏情况：查找（N） 插入（N）平均情况:查找(N/2) 插入(N) 二分查找（有序数组） 最坏情况：查找（logN） 插入（N）平均情况:查找(logN) 插入(N/2) 二叉树查找（BST） 最坏情况：查找（N） 插入（N）平均情况:查找(1.39logN) 插入(1.39logN) 2-3树查找（红黑树） 最坏情况：查找（2logN） 插入（2logN）平均情况:查找(1.00logN) 插入(1.00logN) 约束条件 节点只能是红色或黑色 根节点必须是黑色 所有NIL 节点都是黑色的 一条路径上不能出现相邻的两个红色节点 在任何递归子树内，根节点到叶子节点的所有路径上包含相同数目的黑色节点 左旋：左旋的过程是将x的右子树绕x逆时针旋转，使得x的右子树成为x的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。 treeMap 源码实现 1234567891011121314151617181920212223private void rotateLeft(TreeMap.Entry&lt;K, V&gt; p) &#123; if (p != null) &#123; TreeMap.Entry&lt;K, V&gt; r = p.right; p.right = r.left; if (r.left != null) &#123; r.left.parent = p; &#125; r.parent = p.parent; if (p.parent == null) &#123; this.root = r; &#125; else if (p.parent.left == p) &#123; p.parent.left = r; &#125; else &#123; p.parent.right = r; &#125; r.left = p; p.parent = r; &#125; &#125; 右旋：右旋的过程是将x的左子树绕x顺时针旋转，使得x的左子树成为x的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。 1234567891011121314151617181920212223private void rotateRight(TreeMap.Entry&lt;K, V&gt; p) &#123; if (p != null) &#123; TreeMap.Entry&lt;K, V&gt; l = p.left; p.left = l.right; if (l.right != null) &#123; l.right.parent = p; &#125; l.parent = p.parent; if (p.parent == null) &#123; this.root = l; &#125; else if (p.parent.right == p) &#123; p.parent.right = l; &#125; else &#123; p.parent.left = l; &#125; l.right = p; p.parent = l; &#125; &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[排序]]></title>
    <url>%2F2019%2F08%2F05%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[排序排序是将一组对象按照某种逻辑顺序重新排列的过程。在计算机早期，大家普遍认为30%的计算周期都用在排序上。如今这个比例下降，可能原因之一是如今的排序算法更高效了，而不是说排序的重要性降低了。 既然可以使用标准库中的排序算法，大家为什么还要研究排序呢？ 理解算法有助于解决类似的其他问题 这些算法很经典，优雅，值得去看。 应用于事务处理，组合优化，天体物理学，分子动力学，语言学，基因组学，天气预报等众多领域。其中，快速排序被誉为20世纪科学和工程领域的十大算法之一。 如何来判断算法的成本 计算比较和交换的数量。对于不交换元素的算法，则计算访问数组的次数。 排序算法的额外开销和运行时间同等重要。 12345678910public static boolean less(Comparable v, Comparable w)&#123; return v.comparableTo(w) &lt; 0;&#125;public static void exch(Comparable[] a, int i, int j)&#123; Comparable t = a[i]; a[i] = a[j]; a[j] = t;&#125; 选择排序原理： 找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置。再次，在剩下的元素中找到最小的元素，和数组的第二个元素交换位置，直到最后一个元素为止。 12345678910111213141516public class Selection&#123; public static void sort(Comparable[] a)&#123; int N = a.length(); for(int i = 0; i &lt; N; i ++)&#123; int min = i; //最小元素的索引 for(int j = i+1; j &lt; N; j++)&#123; if(less(a[j], a[min]))&#123; min = j; &#125; &#125; exch(a, i, min); &#125; &#125;&#125; 交换总次数：N比较总次数：N^2 / 2因此这个算法效率取决于比较的次数 运行时间与输入无关。 插入排序为了给插入的元素腾出空间，我们需要将数组的其他元素在插入之前都往右移一位。当索引到达数组的最右端的时候，数组排序就完成了。与选择排序不同的是，插入排序取决于输入元素的初始顺序。 123456789101112131415public class Insertion&#123; public static void sort(Comparable[] a)&#123; int N = a.length; for(int i = 1; i &lt; N; i++)&#123; //将a[i]插入到a[i-1], a[i-2],... for(int j = i; j &gt; 0 &amp;&amp; less(a[j], a[j-1]); j--)&#123; exch(a, a[j], a[j-1]); &#125; &#125; &#125;&#125; 交换总次数：最好的情况需要0次交换，最坏的情况需要N^2 / 2次交换比较总次数：最好的情况需要N-1次比较，最坏的情况需要N^2 / 2次比较 运行时间与输入有关。当对一个很大且已经有序，或者接近有序的数组进行排序会比随机顺序或者逆序数组排序快的多。 希尔排序希尔排序的思想是数组中任意间隔为h的元素都是有序的，这样的数组被称为h有序数组。它是基于插入排序的一种算法。当较大的数替换到后面去，就可以减少比较的次数。 12345678910111213141516171819202122232425public class Shell&#123; public static void sort(Comparable[] a)&#123; int N = a.length; int h = 1; while (h &lt; N /3 ) &#123; //1,4,13,40,121,... h = h * 3 + 1; &#125; while(h &gt;= 1)&#123; for(int i = h; h &lt; N; i++)&#123; //将a[j] 插入到a[i-h], a[i - 2*h], a[i - 3*h],... for(int j = i; j &gt;= h &amp;&amp; less(a[j], a[j-h]); j -= h)&#123; exch(a, j, j-h); &#125; &#125; h = h / 3; &#125; &#125;&#125; 希尔排序不需要额外的空间，而且代码量很小，当没有系统的排序函数可用时，值得优先考虑。 归并排序即两个有序的数组归并成为一个更大的有序数组，这样的递归排序算法成为归并排序。 有序容易，难在归并，所以是如何归并的呢？原地归并的抽象方法： 1234567891011121314151617public static void merge(Comparable[] a, int lo, int mid, int hi)&#123; //将数组[lo..mid]和[mid+1..hi]归并 int i = lo, j = mid+1; for(int k = lo; k &lt;= hi; k++)&#123; aux[k] = a[k]; //将a[lo..hi]复制到aux[lo..hi]中 &#125; for(int k = lo; k &lt;= hi; k++)&#123; if(i &gt; mid) a[k] = aux[j++]; //左半部分用尽了 if(j &gt; hi) a[k] = aux[i++]; //右半部分用尽 if(less(aux[j], aux[i])) a[k] = aux[j++]; //右半部分小于左半部分，取右半部分 else a[k] = aux[i++]; //取左半部分 &#125;&#125; 自顶向下的归并排序实现基于原地归并的抽象实现了另一种递归归并，这也是分治思想的一个典型的例子。 1234567891011121314151617181920public class Merge&#123; public static Comparable[] aux; public static void sort(Comparable[] a)&#123; aux = new Comparable[a.length]; sort(a, 0, a.length-1); &#125; public static void sort(Comparable[] a, int lo, int hi)&#123; if(hi &lt;= lo) return; //结束的标志位 int mid = lo + (hi - lo) / 2; sort(a, lo, mid); //将左半部分排序 sort(a, mid+1, hi); //将右半部分排序 merge(a, lo, mid, hi); //归并 &#125;&#125; 这是分治思想的典型应用。比如要将a[0..15]排序，先会将其分成a[0..7]和a[8..15]排序,然后调用自己会分成a[0..3]和a[4..7]排序，a[0..3]会分成a[0..1]和a[1..2]排序，所以第一次合并就是a[0]和a[1]，a[2]和a[3]合并，在将a[0..1]和a[2..3]合并,以此类推。 假设用一颗树来表示，n表示树的层数，k 表示0到k-1层， 因此，第k层有 2^k 个数组，每个数组中有 2^(n-k)个元素，所以每层比较的次数就是 2^k * 2^(n-k) = 2^n，n层的比较次数就是n*2^n = NlgN。 对于长度N的任意数组，自顶向下的归并排序需要1/2NlgN至NlgN次比较 证明: 令C(N)表示长度为N的数组需要比较的次数，我们有C(0)=C(1)=0,对于N&gt;1，我们有以下公式: C(N) = C(N/2) + C(N/2) + N //左半部分比较次数，右半部分比较次数，N表示归并需要比较的次数,最少归并比较的次数为N/2 假设N为2的幂，即N=2^n,可以得到 C(2^n) = 2C(2^(n-1)) + 2^n， 同时除以 2^n 有， C(2^n)/2^n = C(2^(n-1))/2^(n-1) + 1, 将这个公式代入 C(N/2)，有 C(2^(n-1))/2^(n-1) = C(2^(n-2))/2^(n-2) + 1，所以 C(2^n)/2^n = C(2^(n-2))/2^(n-2) + 1 + 1，所以重复n-1遍，便有 C(2^n)/2^n = C(2^0)/2^0) + n, 同时乘以 2^n, 有 C(2^n) = n*2^n = NlgN。 快速排序快速排序是一种分治的排序算法。它将一个数组分成两个数组，两部分独立的排序。和归并排序不同的是，归并排序是将整个排序好的小数组归并，而快速排序是当子数组排序好了的时候，整个数组自然就排好序了。 算法： 1234567891011121314151617181920212223242526272829public class Quick&#123; public static void sort(Comparable[] a)&#123; StdRandom.shuffle(a); //打乱输入的顺序 sort(a, 0, a.length - 1) &#125; private static void sort(Comparable[] a, int lo, int hi) &#123; if(hi &lt;= lo) return; int j = partition(a, lo, hi); //切分：目的是找到这个j,使得左边的值都比a[j]小，右边的值都比a[j]大 sort(a, lo, j-1); //再利用分治的思想，不断的调用自己找到最小的比较，就得到一个有序的数组 sort(a, j+1, hi); &#125; private static int partition(Comparable[] a, int lo, int hi) &#123; //将数组切分为a[lo..i-1], a[i], a[i+1..hi] int i = lo, j = hi+1; Comparable v = a[lo]; //切分元素 while(true)&#123; while(less(a[++i], v)) if(i == hi) break; while(less(v, a[--j])) if(j == lo) break; if(i &gt;= j) break; exch(a, i, j); &#125; exch(a, lo, j); //将v = a[j] 放入正确的位置,即将a[lo] 与 a[j] 位置互换 return j; &#125;&#125; 描述下切分的策略：首先选择a[lo]作为切分的第一个元素，从左边i=lo+1开始向右扫描，当找到比a[lo]大的元素则停下来，通过从右边j=hi开始向左扫描，当找到比a[lo]小的元素则停下来，交换这两个元素。当i&gt;=j的时候，这一次扫描就结束了，交换a[lo]和a[j]的元素，就可以得到a[j]左边的元素都比它小，右边的元素都比它大。 堆排序优先队列由一个基于堆的完全二叉树表示，存储于数组pq[1..N]中，pq[0]没有使用。完全二叉树：对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。所有的叶子结点都在k层或者k-1层。 当我们要删除N个元素的最大元素(最小元素则相反)或者返回最大元素(最小元素则相反)时，优先队列便非常的有价值。 基于堆的优先队列算法实现: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162puclic class MaxPQ&lt;Key extends Comparable&lt;Key&gt;&gt;&#123; private Key[] pq; private int N = 0; //存储于pq[1..N]中,pq[0]没有使用 public MaxPQ(int maxN)&#123; pq = (Key[])new Comparable[maxN + 1]; &#125; public boolean isEmpty()&#123; return N == 0; &#125; public int size()&#123; return N; &#125; public void insert(Key v)&#123; pq[++N] = v; swin(N); &#125; public Key delMax()&#123; Key max = pq[1]; //从根结点获得最大的元素 exch(1, N-1); //将其和最后一个结点交换 pq[N+1] = null; //防止对象游离 sink(1); //恢复堆的有序性 return max; &#125; private boolean less(int i, int j)&#123; return pq[i].comparableTo(pq[j]) &lt; 0; &#125; private void exch(int i, int j)&#123; Key t = pq[i]; pq[i] = pq[j]; pq[j] = t; &#125; //上浮 private void swin(int k)&#123; //k/2 是k层的父亲节点 while(k &gt; 1 &amp;&amp; less(k/2, k))&#123; exch(k/2, k); k = k/2; &#125; &#125; //下沉 private void sink(int k)&#123; while(2*k &lt;= N)&#123; //k的下一节点则是k*2或k*2+1 int j = 2*k; if(j &lt; N &amp;&amp; less(j, j+1)) j++; if(!less(k, j)) break; exch(k, j); k = j; &#125; &#125;&#125; 堆排序算法实现： 下沉的操作是找到当前结点的所有子结点中最大的元素，交换到子结点。因此堆排序的原理就是：找到最大元素，下沉，再交换。主要工作是在第二阶段。这里我们将最大元素删除，然后放入堆缩小后数组中空出的位置。这个过程和选择排序有点类似，但是比较的次数要少得多，因为堆提供了一种从未排序部分找到最大元素的有效办法。 1234567891011public static void sort(Comparable[] a)&#123; int N = a.length; for(int k = N / 2; k&gt;= 1; k--)&#123; sink(a, k, N); while(N &gt; 1)&#123; exch(a, 1, N--); sink(a, 1, N); &#125; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[重构，改善既有的代码设计]]></title>
    <url>%2F2019%2F08%2F05%2F%E9%87%8D%E6%9E%84-%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E7%9A%84%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[以下将以6次重构的操作来实现一个简单的案例。例子：这是一个影片出租店用的程序，计算每一个顾客的消费金额并打印详单。操作者告诉程序：顾客租了哪些影片，租期多长，程序便根据租赁时间和影片的类型算出费用。影片分为三类：普通片，儿童片和新片。除了计算费用，还要为常客计算积分，积分会根据租片的种类是否为新片而有所不同。 首先提个问题：什么时候重构？ 看代码实现上面案例如下：Movie.java（影片实体类）12345678910111213141516171819202122232425262728293031public class Movie &#123; public static final int CHILEDRENS = 2; public static final int REGULAR = 0; public static final int NEW_RELEASE = 1; public Movie(String title, int priceCode) &#123; this.title = title; this.priceCode = priceCode; &#125; private String title; private int priceCode; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public int getPriceCode() &#123; return priceCode; &#125; public void setPriceCode(int priceCode) &#123; this.priceCode = priceCode; &#125;&#125; Rental.java(租赁类)123456789101112131415161718public class Rental &#123; private Movie movie; private int daysRented; public Rental(Movie movie, int daysRented) &#123; this.movie = movie; this.daysRented = daysRented; &#125; public int getDaysRented() &#123; return daysRented; &#125; public Movie getMovie() &#123; return movie; &#125;&#125; Customer.java(顾客租赁类)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class Customer &#123; private String name; private Vector rentals = new Vector(); public void addRental(Rental arg) &#123; rentals.addElement(arg); &#125; public String getName() &#123; return name; &#125; public String statement() &#123; double totalAmount = 0; int frequentRenterPoints = 0; Enumeration elements = rentals.elements(); StringBuilder result = new StringBuilder("Rental Record for " + getName() + "\n"); while (elements.hasMoreElements()) &#123; double thisAmount = 0; Rental each = (Rental) elements.nextElement(); switch (each.getMovie().getPriceCode()) &#123; case Movie.REGULAR: thisAmount += 2; if (each.getDaysRented() &gt; 2) &#123; thisAmount += (each.getDaysRented() - 2) * 1.5; &#125; break; case Movie.NEW_RELEASE: thisAmount += each.getDaysRented() * 3; break; case Movie.CHILEDRENS: thisAmount += 1.5; if (each.getDaysRented() &gt; 3) &#123; thisAmount += (each.getDaysRented() - 3) * 1.5; &#125; break; &#125; //add frequent renter points frequentRenterPoints ++; //add bonus for a two day new release rental if ((each.getMovie().getPriceCode() == Movie.NEW_RELEASE) &amp;&amp; each.getDaysRented() &gt; 1)&#123; frequentRenterPoints ++; &#125; //show figures for this rental result.append("\t").append(each.getMovie().getTitle()).append("\t").append(String.valueOf(thisAmount)).append("\n"); totalAmount += thisAmount; &#125; //add footer lines result.append("Amount owed is ").append(String.valueOf(totalAmount)).append("\n"); result.append("You earned ").append(String.valueOf(frequentRenterPoints)).append(" frequent renter points"); return result.toString(); &#125;&#125; 以上代码实现完全没有问题，但是能如果遇到以下这两个问题，就会突出臃肿，可扩展性差，难以维护等缺点了。 如果计费标准变化了？ 就需要找到每条case中的计费方式，整个switch语句会十分庞大。 如果想输出statement()中某个数据显示到表单或者被其他地方引用？ 没有任何方法独立提出来，导致重复引用的计算多处出现。 如果你发现自己需要为程序添加一个特性，而代码的结构使你无法很方便地达到目的，那就先重构那个程序，使特性的添加比较容易进行，然后再添加特性。 ###重构（一） 分解并重组statement()12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public String statement() &#123; double totalAmount = 0; int frequentRenterPoints = 0; Enumeration elements = rentals.elements(); StringBuilder result = new StringBuilder("Rental Record for " + getName() + "\n"); while (elements.hasMoreElements()) &#123; double thisAmount = 0; Rental each = (Rental) elements.nextElement(); thisAmount = amountFor(each); //add frequent renter points frequentRenterPoints ++; //add bonus for a two day new release rental if ((each.getMovie().getPriceCode() == Movie.NEW_RELEASE) &amp;&amp; each.getDaysRented() &gt; 1)&#123; frequentRenterPoints ++; &#125; //show figures for this rental result.append("\t").append(each.getMovie().getTitle()).append("\t").append(String.valueOf(thisAmount)).append("\n"); totalAmount += thisAmount; &#125; //add footer lines result.append("Amount owed is ").append(String.valueOf(totalAmount)).append("\n"); result.append("You earned ").append(String.valueOf(frequentRenterPoints)).append(" frequent renter points"); return result.toString(); &#125; private int amountFor(Rental each)&#123; int thisAmount = 0; switch (each.getMovie().getPriceCode()) &#123; case Movie.REGULAR: thisAmount += 2; if (each.getDaysRented() &gt; 2) &#123; thisAmount += (each.getDaysRented() - 2) * 1.5; &#125; break; case Movie.NEW_RELEASE: thisAmount += each.getDaysRented() * 3; break; case Movie.CHILEDRENS: thisAmount += 1.5; if (each.getDaysRented() &gt; 3) &#123; thisAmount += (each.getDaysRented() - 3) * 1.5; &#125; break; &#125; return thisAmount; &#125; 每次做完一次这样的修改都要编译并测试。这次测试发现错误了吧。故意把返回的double改成了int类型。 就是为了告诉我们每次修改都要非常小心，并且编译测试，不但不会浪费时间，反而会节省大量的调试时间。 ###重构（二） 修改函数名称/参数名称123456789101112131415161718192021private double amountFor(Rental rental)&#123; double result = 0; switch (rental.getMovie().getPriceCode()) &#123; case Movie.REGULAR: result += 2; if (rental.getDaysRented() &gt; 2) &#123; result += (rental.getDaysRented() - 2) * 1.5; &#125; break; case Movie.NEW_RELEASE: result += rental.getDaysRented() * 3; break; case Movie.CHILEDRENS: result += 1.5; if (rental.getDaysRented() &gt; 3) &#123; result += (rental.getDaysRented() - 3) * 1.5; &#125; break; &#125; return result; &#125; 任何一个傻瓜都可以写出计算机可以理解的代码，唯有写出人类容易理解的代码，才是优秀的程序员。 ###重构（三） 搬移函数（移动到它该到的地方去）123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Customer &#123; private String name; private Vector rentals = new Vector(); public void addRental(Rental arg) &#123; rentals.addElement(arg); &#125; public String getName() &#123; return name; &#125; public String statement() &#123; double totalAmount = 0; int frequentRenterPoints = 0; Enumeration elements = rentals.elements(); StringBuilder result = new StringBuilder("Rental Record for " + getName() + "\n"); while (elements.hasMoreElements()) &#123; double thisAmount = 0; Rental each = (Rental) elements.nextElement(); thisAmount = amountFor(each); //add frequent renter points frequentRenterPoints ++; //add bonus for a two day new release rental if ((each.getMovie().getPriceCode() == Movie.NEW_RELEASE) &amp;&amp; each.getDaysRented() &gt; 1)&#123; frequentRenterPoints ++; &#125; //show figures for this rental result.append("\t").append(each.getMovie().getTitle()).append("\t").append(String.valueOf(thisAmount)).append("\n"); totalAmount += thisAmount; &#125; //add footer lines result.append("Amount owed is ").append(String.valueOf(totalAmount)).append("\n"); result.append("You earned ").append(String.valueOf(frequentRenterPoints)).append(" frequent renter points"); return result.toString(); &#125; private double amountFor(Rental rental)&#123; return rental.getCharge(); &#125;&#125; Rental.java类12345678910111213141516171819202122232425262728293031323334353637383940public class Rental &#123; private Movie movie; private int daysRented; public Rental(Movie movie, int daysRented) &#123; this.movie = movie; this.daysRented = daysRented; &#125; public int getDaysRented() &#123; return daysRented; &#125; public Movie getMovie() &#123; return movie; &#125; double getCharge()&#123; double result = 0; switch (getMovie().getPriceCode()) &#123; case Movie.REGULAR: result += 2; if (getDaysRented() &gt; 2) &#123; result += (getDaysRented() - 2) * 1.5; &#125; break; case Movie.NEW_RELEASE: result += getDaysRented() * 3; break; case Movie.CHILEDRENS: result += 1.5; if (getDaysRented() &gt; 3) &#123; result += (getDaysRented() - 3) * 1.5; &#125; break; &#125; return result; &#125;&#125; 重构（四）提炼函数(越细小的函数功能越明确)/去除临时变量(使结构更清晰)1234567891011121314151617181920212223242526272829303132333435public String statement() &#123; Enumeration elements = rentals.elements(); StringBuilder result = new StringBuilder("Rental Record for " + getName() + "\n"); while (elements.hasMoreElements()) &#123; Rental each = (Rental) elements.nextElement(); //show figures for this rental result.append("\t").append(each.getMovie().getTitle()).append("\t").append(String.valueOf(each.getCharge())).append("\n"); &#125; //add footer lines result.append("Amount owed is ").append(String.valueOf(getTotalCharge())).append("\n"); result.append("You earned ").append(String.valueOf(getTotalFrequentRenterPoints())).append(" frequent renter points"); return result.toString(); &#125; private double getTotalCharge()&#123; double result = 0; Enumeration enumeration = rentals.elements(); while (enumeration.hasMoreElements())&#123; Rental each = (Rental) enumeration.nextElement(); result += each.getCharge(); &#125; return result; &#125; private int getTotalFrequentRenterPoints()&#123; int result = 0; Enumeration enumeration = rentals.elements(); while (enumeration.hasMoreElements())&#123; Rental each = (Rental) enumeration.nextElement(); result += each.getFrequentRenterPoints(); &#125; return result; &#125; Rental.java类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Rental &#123; private Movie movie; private int daysRented; public Rental(Movie movie, int daysRented) &#123; this.movie = movie; this.daysRented = daysRented; &#125; public int getDaysRented() &#123; return daysRented; &#125; public Movie getMovie() &#123; return movie; &#125; double getCharge()&#123; double result = 0; switch (getMovie().getPriceCode()) &#123; case Movie.REGULAR: result += 2; if (getDaysRented() &gt; 2) &#123; result += (getDaysRented() - 2) * 1.5; &#125; break; case Movie.NEW_RELEASE: result += getDaysRented() * 3; break; case Movie.CHILEDRENS: result += 1.5; if (getDaysRented() &gt; 3) &#123; result += (getDaysRented() - 3) * 1.5; &#125; break; &#125; return result; &#125; int getFrequentRenterPoints()&#123; if ((getMovie().getPriceCode() == Movie.NEW_RELEASE) &amp;&amp; getDaysRented() &gt; 1)&#123; return 2; &#125;else &#123; return 1; &#125; &#125;&#125; ###重构（五） 多态来提炼switch()语句 这里不直接抽象Movie类，是因为Movie类有自己的属性和生命周期。所以State模式的应用可以很好的解决这个问题。 Movie.java类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Movie &#123; public static final int CHILEDRENS = 2; public static final int REGULAR = 0; public static final int NEW_RELEASE = 1; public Movie(String title, int priceCode) &#123; this.title = title; setPriceCode(priceCode); &#125; public void setPriceCode(int arg) &#123; switch (arg) &#123; case REGULAR: price = new RegularPrice(); break; case CHILEDRENS: price = new ChildrensPrice(); break; case NEW_RELEASE: price = new NewReleasePrice(); break; default: throw new IllegalArgumentException("incorrect price code"); &#125; &#125; private String title; private Price price; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public Price getPrice() &#123; return price; &#125; public void setPrice(Price price) &#123; this.price = price; &#125; double getCharge(int daysRented) &#123; return price.getCharge(daysRented); &#125; int getFrequentRenterPoints(int daysRented) &#123; return price.getFrequentRenterPoints(daysRented); &#125;&#125; Price.java类12345678910111213141516171819202122232425262728293031323334abstract class Price &#123; abstract int getPriceCode(); double getCharge(int daysRented)&#123; double result = 0; switch (getPriceCode()) &#123; case Movie.REGULAR: result += 2; if (daysRented &gt; 2) &#123; result += (daysRented - 2) * 1.5; &#125; break; case Movie.NEW_RELEASE: result += daysRented * 3; break; case Movie.CHILEDRENS: result += 1.5; if (daysRented &gt; 3) &#123; result += (daysRented - 3) * 1.5; &#125; break; &#125; return result; &#125; int getFrequentRenterPoints(int daysRented) &#123; if ((getPriceCode() == Movie.NEW_RELEASE) &amp;&amp; daysRented &gt; 1) &#123; return 2; &#125; else &#123; return 1; &#125; &#125;&#125; NewReleasePrice.java类123456public class NewReleasePrice extends Price &#123; @Override int getPriceCode() &#123; return Movie.NEW_RELEASE; &#125;&#125; 其他两个实现类同NewReleasePrice类，就不列出来了。 ###重构（六） 继承12345678910abstract class Price &#123; abstract int getPriceCode(); abstract double getCharge(int daysRented); int getFrequentRenterPoints(int daysRented) &#123; return 1; &#125;&#125; NewReleasePrice.java类12345678910111213141516public class NewReleasePrice extends Price &#123; @Override int getPriceCode() &#123; return Movie.NEW_RELEASE; &#125; @Override double getCharge(int daysRented) &#123; return daysRented * 3; &#125; @Override int getFrequentRenterPoints(int daysRented) &#123; return (daysRented &gt; 1) ? 2 : 1; &#125;&#125; 前面列出的技术点仅仅只是一个起点，使你登堂入室之前的大门。如果没有这些技术，你根本无法对运行的程序进行任何设计上的改动。有了这些技术，你仍然做不到，但起码可以开始尝试了。]]></content>
  </entry>
</search>

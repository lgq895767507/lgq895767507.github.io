<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[排序]]></title>
    <url>%2F2019%2F08%2F05%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[排序是将一组对象按照某种逻辑顺序重新排列的过程。在计算机早期，大家普遍认为30%的计算周期都用在排序上。如今这个比例下降，可能原因之一是如今的排序算法更高效了，而不是说排序的重要性降低了。 既然可以使用标准库中的排序算法，大家为什么还要研究排序呢？ 理解算法有助于解决类似的其他问题 这些算法很经典，优雅，值得去看。 应用于事务处理，组合优化，天体物理学，分子动力学，语言学，基因组学，天气预报等众多领域。其中，快速排序被誉为20世纪科学和工程领域的十大算法之一。 如何来判断算法的成本 计算比较和交换的数量。对于不交换元素的算法，则计算访问数组的次数。 排序算法的额外开销和运行时间同等重要。 12345678910public static boolean less(Comparable v, Comparable w)&#123; return v.comparableTo(w) &lt; 0;&#125;public static void exch(Comparable[] a, int i, int j)&#123; Comparable t = a[i]; a[i] = a[j]; a[j] = t;&#125; 选择排序原理： 找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置。再次，在剩下的元素中找到最小的元素，和数组的第二个元素交换位置，直到最后一个元素为止。 12345678910111213141516public class Selection&#123; public static void sort(Comparable[] a)&#123; int N = a.length(); for(int i = 0; i &lt; N; i ++)&#123; int min = i; //最小元素的索引 for(int j = i+1; j &lt; N; j++)&#123; if(less(a[j], a[min]))&#123; min = j; &#125; &#125; exch(a, i, min); &#125; &#125;&#125; 交换总次数：N比较总次数：N^2 / 2因此这个算法效率取决于比较的次数 运行时间与输入无关。 插入排序为了给插入的元素腾出空间，我们需要将数组的其他元素在插入之前都往右移一位。当索引到达数组的最右端的时候，数组排序就完成了。与选择排序不同的是，插入排序取决于输入元素的初始顺序。 123456789101112131415public class Insertion&#123; public static void sort(Comparable[] a)&#123; int N = a.length; for(int i = 1; i &lt; N; i++)&#123; //将a[i]插入到a[i-1], a[i-2],... for(int j = i; j &gt; 0 &amp;&amp; less(a[j], a[j-1]); j--)&#123; exch(a, a[j], a[j-1]); &#125; &#125; &#125;&#125; 交换总次数：最好的情况需要0次交换，最坏的情况需要N^2 / 2次交换比较总次数：最好的情况需要N-1次比较，最坏的情况需要N^2 / 2次比较 运行时间与输入有关。当对一个很大且已经有序，或者接近有序的数组进行排序会比随机顺序或者逆序数组排序快的多。 希尔排序希尔排序的思想是数组中任意间隔为h的元素都是有序的，这样的数组被称为h有序数组。它是基于插入排序的一种算法。当较大的数替换到后面去，就可以减少比较的次数。 12345678910111213141516171819202122232425public class Shell&#123; public static void sort(Comparable[] a)&#123; int N = a.length; int h = 1; while (h &lt; N /3 ) &#123; //1,4,13,40,121,... h = h * 3 + 1; &#125; while(h &gt;= 1)&#123; for(int i = h; h &lt; N; i++)&#123; //将a[j] 插入到a[i-h], a[i - 2*h], a[i - 3*h],... for(int j = i; j &gt;= h &amp;&amp; less(a[j], a[j-h]); j -= h)&#123; exch(a, j, j-h); &#125; &#125; h = h / 3; &#125; &#125;&#125; 希尔排序不需要额外的空间，而且代码量很小，当没有系统的排序函数可用时，值得优先考虑。 归并排序即两个有序的数组归并成为一个更大的有序数组，这样的递归排序算法成为归并排序。 有序容易，难在归并，所以是如何归并的呢？原地归并的抽象方法： 1234567891011121314151617public static void merge(Comparable[] a, int lo, int mid, int hi)&#123; //将数组[lo..mid]和[mid+1..hi]归并 int i = lo, j = mid+1; for(int k = lo; k &lt;= hi; k++)&#123; aux[k] = a[k]; //将a[lo..hi]复制到aux[lo..hi]中 &#125; for(int k = lo; k &lt;= hi; k++)&#123; if(i &gt; mid) a[k] = aux[j++]; //左半部分用尽了 if(j &gt; hi) a[k] = aux[i++]; //右半部分用尽 if(less(aux[j], aux[i])) a[k] = aux[j++]; //右半部分小于左半部分，取右半部分 else a[k] = aux[i++]; //取左半部分 &#125;&#125; 自顶向下的归并排序实现基于原地归并的抽象实现了另一种递归归并，这也是分治思想的一个典型的例子。 1234567891011121314151617181920public class Merge&#123; public static Comparable[] aux; public static void sort(Comparable[] a)&#123; aux = new Comparable[a.length]; sort(a, 0, a.length-1); &#125; public static void sort(Comparable[] a, int lo, int hi)&#123; if(hi &lt;= lo) return; //结束的标志位 int mid = lo + (hi - lo) / 2; sort(a, lo, mid); //将左半部分排序 sort(a, mid+1, hi); //将右半部分排序 merge(a, lo, mid, hi); //归并 &#125;&#125; 假设用一颗树来表示，n表示树的层数，k 表示0到k-1层， 因此，第k层有 2^k 个数组，每个数组中有 2^(n-k)个元素，所以每层比较的次数就是 2^k * 2^(n-k) = 2^n，n层的比较次数就是n*2^n = NlgN。 对于长度N的任意数组，自顶向下的归并排序需要1/2NlgN至NlgN次比较 证明: 令C(N)表示长度为N的数组需要比较的次数，我们有C(0)=C(1)=0,对于N&gt;1，我们有以下公式: C(N) = C(N/2) + C(N/2) + N //左半部分比较次数，右半部分比较次数，N表示归并需要比较的次数,最少归并比较的次数为N/2 假设N为2的幂，即N=2^n,可以得到 C(2^n) = 2C(2^(n-1)) + 2^n， 同时除以 2^n 有， C(2^n)/2^n = C(2^(n-1))/2^(n-1) + 1, 将这个公式代入 C(N/2)，有 C(2^(n-1))/2^(n-1) = C(2^(n-2))/2^(n-2) + 1，所以 C(2^n)/2^n = C(2^(n-2))/2^(n-2) + 1 + 1，所以重复n-1遍，便有 C(2^n)/2^n = C(2^0)/2^0) + n, 同时乘以 2^n, 有 C(2^n) = n*2^n = NlgN。 快速排序堆排序]]></content>
  </entry>
  <entry>
    <title><![CDATA[重构，改善既有的代码设计]]></title>
    <url>%2F2019%2F08%2F05%2F%E9%87%8D%E6%9E%84-%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E7%9A%84%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[以下将以6次重构的操作来实现一个简单的案例。例子：这是一个影片出租店用的程序，计算每一个顾客的消费金额并打印详单。操作者告诉程序：顾客租了哪些影片，租期多长，程序便根据租赁时间和影片的类型算出费用。影片分为三类：普通片，儿童片和新片。除了计算费用，还要为常客计算积分，积分会根据租片的种类是否为新片而有所不同。 首先提个问题：什么时候重构？ 看代码实现上面案例如下：Movie.java（影片实体类）12345678910111213141516171819202122232425262728293031public class Movie &#123; public static final int CHILEDRENS = 2; public static final int REGULAR = 0; public static final int NEW_RELEASE = 1; public Movie(String title, int priceCode) &#123; this.title = title; this.priceCode = priceCode; &#125; private String title; private int priceCode; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public int getPriceCode() &#123; return priceCode; &#125; public void setPriceCode(int priceCode) &#123; this.priceCode = priceCode; &#125;&#125; Rental.java(租赁类)123456789101112131415161718public class Rental &#123; private Movie movie; private int daysRented; public Rental(Movie movie, int daysRented) &#123; this.movie = movie; this.daysRented = daysRented; &#125; public int getDaysRented() &#123; return daysRented; &#125; public Movie getMovie() &#123; return movie; &#125;&#125; Customer.java(顾客租赁类)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class Customer &#123; private String name; private Vector rentals = new Vector(); public void addRental(Rental arg) &#123; rentals.addElement(arg); &#125; public String getName() &#123; return name; &#125; public String statement() &#123; double totalAmount = 0; int frequentRenterPoints = 0; Enumeration elements = rentals.elements(); StringBuilder result = new StringBuilder("Rental Record for " + getName() + "\n"); while (elements.hasMoreElements()) &#123; double thisAmount = 0; Rental each = (Rental) elements.nextElement(); switch (each.getMovie().getPriceCode()) &#123; case Movie.REGULAR: thisAmount += 2; if (each.getDaysRented() &gt; 2) &#123; thisAmount += (each.getDaysRented() - 2) * 1.5; &#125; break; case Movie.NEW_RELEASE: thisAmount += each.getDaysRented() * 3; break; case Movie.CHILEDRENS: thisAmount += 1.5; if (each.getDaysRented() &gt; 3) &#123; thisAmount += (each.getDaysRented() - 3) * 1.5; &#125; break; &#125; //add frequent renter points frequentRenterPoints ++; //add bonus for a two day new release rental if ((each.getMovie().getPriceCode() == Movie.NEW_RELEASE) &amp;&amp; each.getDaysRented() &gt; 1)&#123; frequentRenterPoints ++; &#125; //show figures for this rental result.append("\t").append(each.getMovie().getTitle()).append("\t").append(String.valueOf(thisAmount)).append("\n"); totalAmount += thisAmount; &#125; //add footer lines result.append("Amount owed is ").append(String.valueOf(totalAmount)).append("\n"); result.append("You earned ").append(String.valueOf(frequentRenterPoints)).append(" frequent renter points"); return result.toString(); &#125;&#125; 以上代码实现完全没有问题，但是能如果遇到以下这两个问题，就会突出臃肿，可扩展性差，难以维护等缺点了。 如果计费标准变化了？ 就需要找到每条case中的计费方式，整个switch语句会十分庞大。 如果想输出statement()中某个数据显示到表单或者被其他地方引用？ 没有任何方法独立提出来，导致重复引用的计算多处出现。 如果你发现自己需要为程序添加一个特性，而代码的结构使你无法很方便地达到目的，那就先重构那个程序，使特性的添加比较容易进行，然后再添加特性。 ###重构（一） 分解并重组statement()12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public String statement() &#123; double totalAmount = 0; int frequentRenterPoints = 0; Enumeration elements = rentals.elements(); StringBuilder result = new StringBuilder("Rental Record for " + getName() + "\n"); while (elements.hasMoreElements()) &#123; double thisAmount = 0; Rental each = (Rental) elements.nextElement(); thisAmount = amountFor(each); //add frequent renter points frequentRenterPoints ++; //add bonus for a two day new release rental if ((each.getMovie().getPriceCode() == Movie.NEW_RELEASE) &amp;&amp; each.getDaysRented() &gt; 1)&#123; frequentRenterPoints ++; &#125; //show figures for this rental result.append("\t").append(each.getMovie().getTitle()).append("\t").append(String.valueOf(thisAmount)).append("\n"); totalAmount += thisAmount; &#125; //add footer lines result.append("Amount owed is ").append(String.valueOf(totalAmount)).append("\n"); result.append("You earned ").append(String.valueOf(frequentRenterPoints)).append(" frequent renter points"); return result.toString(); &#125; private int amountFor(Rental each)&#123; int thisAmount = 0; switch (each.getMovie().getPriceCode()) &#123; case Movie.REGULAR: thisAmount += 2; if (each.getDaysRented() &gt; 2) &#123; thisAmount += (each.getDaysRented() - 2) * 1.5; &#125; break; case Movie.NEW_RELEASE: thisAmount += each.getDaysRented() * 3; break; case Movie.CHILEDRENS: thisAmount += 1.5; if (each.getDaysRented() &gt; 3) &#123; thisAmount += (each.getDaysRented() - 3) * 1.5; &#125; break; &#125; return thisAmount; &#125; 每次做完一次这样的修改都要编译并测试。这次测试发现错误了吧。故意把返回的double改成了int类型。 就是为了告诉我们每次修改都要非常小心，并且编译测试，不但不会浪费时间，反而会节省大量的调试时间。 ###重构（二） 修改函数名称/参数名称123456789101112131415161718192021private double amountFor(Rental rental)&#123; double result = 0; switch (rental.getMovie().getPriceCode()) &#123; case Movie.REGULAR: result += 2; if (rental.getDaysRented() &gt; 2) &#123; result += (rental.getDaysRented() - 2) * 1.5; &#125; break; case Movie.NEW_RELEASE: result += rental.getDaysRented() * 3; break; case Movie.CHILEDRENS: result += 1.5; if (rental.getDaysRented() &gt; 3) &#123; result += (rental.getDaysRented() - 3) * 1.5; &#125; break; &#125; return result; &#125; 任何一个傻瓜都可以写出计算机可以理解的代码，唯有写出人类容易理解的代码，才是优秀的程序员。 ###重构（三） 搬移函数（移动到它该到的地方去）123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Customer &#123; private String name; private Vector rentals = new Vector(); public void addRental(Rental arg) &#123; rentals.addElement(arg); &#125; public String getName() &#123; return name; &#125; public String statement() &#123; double totalAmount = 0; int frequentRenterPoints = 0; Enumeration elements = rentals.elements(); StringBuilder result = new StringBuilder("Rental Record for " + getName() + "\n"); while (elements.hasMoreElements()) &#123; double thisAmount = 0; Rental each = (Rental) elements.nextElement(); thisAmount = amountFor(each); //add frequent renter points frequentRenterPoints ++; //add bonus for a two day new release rental if ((each.getMovie().getPriceCode() == Movie.NEW_RELEASE) &amp;&amp; each.getDaysRented() &gt; 1)&#123; frequentRenterPoints ++; &#125; //show figures for this rental result.append("\t").append(each.getMovie().getTitle()).append("\t").append(String.valueOf(thisAmount)).append("\n"); totalAmount += thisAmount; &#125; //add footer lines result.append("Amount owed is ").append(String.valueOf(totalAmount)).append("\n"); result.append("You earned ").append(String.valueOf(frequentRenterPoints)).append(" frequent renter points"); return result.toString(); &#125; private double amountFor(Rental rental)&#123; return rental.getCharge(); &#125;&#125; Rental.java类12345678910111213141516171819202122232425262728293031323334353637383940public class Rental &#123; private Movie movie; private int daysRented; public Rental(Movie movie, int daysRented) &#123; this.movie = movie; this.daysRented = daysRented; &#125; public int getDaysRented() &#123; return daysRented; &#125; public Movie getMovie() &#123; return movie; &#125; double getCharge()&#123; double result = 0; switch (getMovie().getPriceCode()) &#123; case Movie.REGULAR: result += 2; if (getDaysRented() &gt; 2) &#123; result += (getDaysRented() - 2) * 1.5; &#125; break; case Movie.NEW_RELEASE: result += getDaysRented() * 3; break; case Movie.CHILEDRENS: result += 1.5; if (getDaysRented() &gt; 3) &#123; result += (getDaysRented() - 3) * 1.5; &#125; break; &#125; return result; &#125;&#125; 重构（四）提炼函数(越细小的函数功能越明确)/去除临时变量(使结构更清晰)1234567891011121314151617181920212223242526272829303132333435public String statement() &#123; Enumeration elements = rentals.elements(); StringBuilder result = new StringBuilder("Rental Record for " + getName() + "\n"); while (elements.hasMoreElements()) &#123; Rental each = (Rental) elements.nextElement(); //show figures for this rental result.append("\t").append(each.getMovie().getTitle()).append("\t").append(String.valueOf(each.getCharge())).append("\n"); &#125; //add footer lines result.append("Amount owed is ").append(String.valueOf(getTotalCharge())).append("\n"); result.append("You earned ").append(String.valueOf(getTotalFrequentRenterPoints())).append(" frequent renter points"); return result.toString(); &#125; private double getTotalCharge()&#123; double result = 0; Enumeration enumeration = rentals.elements(); while (enumeration.hasMoreElements())&#123; Rental each = (Rental) enumeration.nextElement(); result += each.getCharge(); &#125; return result; &#125; private int getTotalFrequentRenterPoints()&#123; int result = 0; Enumeration enumeration = rentals.elements(); while (enumeration.hasMoreElements())&#123; Rental each = (Rental) enumeration.nextElement(); result += each.getFrequentRenterPoints(); &#125; return result; &#125; Rental.java类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Rental &#123; private Movie movie; private int daysRented; public Rental(Movie movie, int daysRented) &#123; this.movie = movie; this.daysRented = daysRented; &#125; public int getDaysRented() &#123; return daysRented; &#125; public Movie getMovie() &#123; return movie; &#125; double getCharge()&#123; double result = 0; switch (getMovie().getPriceCode()) &#123; case Movie.REGULAR: result += 2; if (getDaysRented() &gt; 2) &#123; result += (getDaysRented() - 2) * 1.5; &#125; break; case Movie.NEW_RELEASE: result += getDaysRented() * 3; break; case Movie.CHILEDRENS: result += 1.5; if (getDaysRented() &gt; 3) &#123; result += (getDaysRented() - 3) * 1.5; &#125; break; &#125; return result; &#125; int getFrequentRenterPoints()&#123; if ((getMovie().getPriceCode() == Movie.NEW_RELEASE) &amp;&amp; getDaysRented() &gt; 1)&#123; return 2; &#125;else &#123; return 1; &#125; &#125;&#125; ###重构（五） 多态来提炼switch()语句 这里不直接抽象Movie类，是因为Movie类有自己的属性和生命周期。所以State模式的应用可以很好的解决这个问题。 Movie.java类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Movie &#123; public static final int CHILEDRENS = 2; public static final int REGULAR = 0; public static final int NEW_RELEASE = 1; public Movie(String title, int priceCode) &#123; this.title = title; setPriceCode(priceCode); &#125; public void setPriceCode(int arg) &#123; switch (arg) &#123; case REGULAR: price = new RegularPrice(); break; case CHILEDRENS: price = new ChildrensPrice(); break; case NEW_RELEASE: price = new NewReleasePrice(); break; default: throw new IllegalArgumentException("incorrect price code"); &#125; &#125; private String title; private Price price; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public Price getPrice() &#123; return price; &#125; public void setPrice(Price price) &#123; this.price = price; &#125; double getCharge(int daysRented) &#123; return price.getCharge(daysRented); &#125; int getFrequentRenterPoints(int daysRented) &#123; return price.getFrequentRenterPoints(daysRented); &#125;&#125; Price.java类12345678910111213141516171819202122232425262728293031323334abstract class Price &#123; abstract int getPriceCode(); double getCharge(int daysRented)&#123; double result = 0; switch (getPriceCode()) &#123; case Movie.REGULAR: result += 2; if (daysRented &gt; 2) &#123; result += (daysRented - 2) * 1.5; &#125; break; case Movie.NEW_RELEASE: result += daysRented * 3; break; case Movie.CHILEDRENS: result += 1.5; if (daysRented &gt; 3) &#123; result += (daysRented - 3) * 1.5; &#125; break; &#125; return result; &#125; int getFrequentRenterPoints(int daysRented) &#123; if ((getPriceCode() == Movie.NEW_RELEASE) &amp;&amp; daysRented &gt; 1) &#123; return 2; &#125; else &#123; return 1; &#125; &#125;&#125; NewReleasePrice.java类123456public class NewReleasePrice extends Price &#123; @Override int getPriceCode() &#123; return Movie.NEW_RELEASE; &#125;&#125; 其他两个实现类同NewReleasePrice类，就不列出来了。 ###重构（六） 继承12345678910abstract class Price &#123; abstract int getPriceCode(); abstract double getCharge(int daysRented); int getFrequentRenterPoints(int daysRented) &#123; return 1; &#125;&#125; NewReleasePrice.java类12345678910111213141516public class NewReleasePrice extends Price &#123; @Override int getPriceCode() &#123; return Movie.NEW_RELEASE; &#125; @Override double getCharge(int daysRented) &#123; return daysRented * 3; &#125; @Override int getFrequentRenterPoints(int daysRented) &#123; return (daysRented &gt; 1) ? 2 : 1; &#125;&#125; 前面列出的技术点仅仅只是一个起点，使你登堂入室之前的大门。如果没有这些技术，你根本无法对运行的程序进行任何设计上的改动。有了这些技术，你仍然做不到，但起码可以开始尝试了。]]></content>
  </entry>
</search>

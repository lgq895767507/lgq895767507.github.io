<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F08%2F05%2F%E9%87%8D%E6%9E%84-%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E7%9A%84%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[重构，改善既有的代码设计 以下将以6次重构的操作来实现一个简单的案例。例子：这是一个影片出租店用的程序，计算每一个顾客的消费金额并打印详单。操作者告诉程序：顾客租了哪些影片，租期多长，程序便根据租赁时间和影片的类型算出费用。影片分为三类：普通片，儿童片和新片。除了计算费用，还要为常客计算积分，积分会根据租片的种类是否为新片而有所不同。 首先提个问题：什么时候重构？ 看代码实现上面案例如下：Movie.java（影片实体类）12345678910111213141516171819202122232425262728293031public class Movie &#123; public static final int CHILEDRENS = 2; public static final int REGULAR = 0; public static final int NEW_RELEASE = 1; public Movie(String title, int priceCode) &#123; this.title = title; this.priceCode = priceCode; &#125; private String title; private int priceCode; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public int getPriceCode() &#123; return priceCode; &#125; public void setPriceCode(int priceCode) &#123; this.priceCode = priceCode; &#125;&#125; Rental.java(租赁类)123456789101112131415161718public class Rental &#123; private Movie movie; private int daysRented; public Rental(Movie movie, int daysRented) &#123; this.movie = movie; this.daysRented = daysRented; &#125; public int getDaysRented() &#123; return daysRented; &#125; public Movie getMovie() &#123; return movie; &#125;&#125; Customer.java(顾客租赁类)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class Customer &#123; private String name; private Vector rentals = new Vector(); public void addRental(Rental arg) &#123; rentals.addElement(arg); &#125; public String getName() &#123; return name; &#125; public String statement() &#123; double totalAmount = 0; int frequentRenterPoints = 0; Enumeration elements = rentals.elements(); StringBuilder result = new StringBuilder("Rental Record for " + getName() + "\n"); while (elements.hasMoreElements()) &#123; double thisAmount = 0; Rental each = (Rental) elements.nextElement(); switch (each.getMovie().getPriceCode()) &#123; case Movie.REGULAR: thisAmount += 2; if (each.getDaysRented() &gt; 2) &#123; thisAmount += (each.getDaysRented() - 2) * 1.5; &#125; break; case Movie.NEW_RELEASE: thisAmount += each.getDaysRented() * 3; break; case Movie.CHILEDRENS: thisAmount += 1.5; if (each.getDaysRented() &gt; 3) &#123; thisAmount += (each.getDaysRented() - 3) * 1.5; &#125; break; &#125; //add frequent renter points frequentRenterPoints ++; //add bonus for a two day new release rental if ((each.getMovie().getPriceCode() == Movie.NEW_RELEASE) &amp;&amp; each.getDaysRented() &gt; 1)&#123; frequentRenterPoints ++; &#125; //show figures for this rental result.append("\t").append(each.getMovie().getTitle()).append("\t").append(String.valueOf(thisAmount)).append("\n"); totalAmount += thisAmount; &#125; //add footer lines result.append("Amount owed is ").append(String.valueOf(totalAmount)).append("\n"); result.append("You earned ").append(String.valueOf(frequentRenterPoints)).append(" frequent renter points"); return result.toString(); &#125;&#125; 以上代码实现完全没有问题，但是能如果遇到以下这两个问题，就会突出臃肿，可扩展性差，难以维护等缺点了。 如果计费标准变化了？ 就需要找到每条case中的计费方式，整个switch语句会十分庞大。 如果想输出statement()中某个数据显示到表单或者被其他地方引用？ 没有任何方法独立提出来，导致重复引用的计算多处出现。 如果你发现自己需要为程序添加一个特性，而代码的结构使你无法很方便地达到目的，那就先重构那个程序，使特性的添加比较容易进行，然后再添加特性。 ###重构（一） 分解并重组statement()12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public String statement() &#123; double totalAmount = 0; int frequentRenterPoints = 0; Enumeration elements = rentals.elements(); StringBuilder result = new StringBuilder("Rental Record for " + getName() + "\n"); while (elements.hasMoreElements()) &#123; double thisAmount = 0; Rental each = (Rental) elements.nextElement(); thisAmount = amountFor(each); //add frequent renter points frequentRenterPoints ++; //add bonus for a two day new release rental if ((each.getMovie().getPriceCode() == Movie.NEW_RELEASE) &amp;&amp; each.getDaysRented() &gt; 1)&#123; frequentRenterPoints ++; &#125; //show figures for this rental result.append("\t").append(each.getMovie().getTitle()).append("\t").append(String.valueOf(thisAmount)).append("\n"); totalAmount += thisAmount; &#125; //add footer lines result.append("Amount owed is ").append(String.valueOf(totalAmount)).append("\n"); result.append("You earned ").append(String.valueOf(frequentRenterPoints)).append(" frequent renter points"); return result.toString(); &#125; private int amountFor(Rental each)&#123; int thisAmount = 0; switch (each.getMovie().getPriceCode()) &#123; case Movie.REGULAR: thisAmount += 2; if (each.getDaysRented() &gt; 2) &#123; thisAmount += (each.getDaysRented() - 2) * 1.5; &#125; break; case Movie.NEW_RELEASE: thisAmount += each.getDaysRented() * 3; break; case Movie.CHILEDRENS: thisAmount += 1.5; if (each.getDaysRented() &gt; 3) &#123; thisAmount += (each.getDaysRented() - 3) * 1.5; &#125; break; &#125; return thisAmount; &#125; 每次做完一次这样的修改都要编译并测试。这次测试发现错误了吧。故意把返回的double改成了int类型。 就是为了告诉我们每次修改都要非常小心，并且编译测试，不但不会浪费时间，反而会节省大量的调试时间。 ###重构（二） 修改函数名称/参数名称123456789101112131415161718192021private double amountFor(Rental rental)&#123; double result = 0; switch (rental.getMovie().getPriceCode()) &#123; case Movie.REGULAR: result += 2; if (rental.getDaysRented() &gt; 2) &#123; result += (rental.getDaysRented() - 2) * 1.5; &#125; break; case Movie.NEW_RELEASE: result += rental.getDaysRented() * 3; break; case Movie.CHILEDRENS: result += 1.5; if (rental.getDaysRented() &gt; 3) &#123; result += (rental.getDaysRented() - 3) * 1.5; &#125; break; &#125; return result; &#125; 任何一个傻瓜都可以写出计算机可以理解的代码，唯有写出人类容易理解的代码，才是优秀的程序员。 ###重构（三） 搬移函数（移动到它该到的地方去）123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Customer &#123; private String name; private Vector rentals = new Vector(); public void addRental(Rental arg) &#123; rentals.addElement(arg); &#125; public String getName() &#123; return name; &#125; public String statement() &#123; double totalAmount = 0; int frequentRenterPoints = 0; Enumeration elements = rentals.elements(); StringBuilder result = new StringBuilder("Rental Record for " + getName() + "\n"); while (elements.hasMoreElements()) &#123; double thisAmount = 0; Rental each = (Rental) elements.nextElement(); thisAmount = amountFor(each); //add frequent renter points frequentRenterPoints ++; //add bonus for a two day new release rental if ((each.getMovie().getPriceCode() == Movie.NEW_RELEASE) &amp;&amp; each.getDaysRented() &gt; 1)&#123; frequentRenterPoints ++; &#125; //show figures for this rental result.append("\t").append(each.getMovie().getTitle()).append("\t").append(String.valueOf(thisAmount)).append("\n"); totalAmount += thisAmount; &#125; //add footer lines result.append("Amount owed is ").append(String.valueOf(totalAmount)).append("\n"); result.append("You earned ").append(String.valueOf(frequentRenterPoints)).append(" frequent renter points"); return result.toString(); &#125; private double amountFor(Rental rental)&#123; return rental.getCharge(); &#125;&#125; Rental.java类12345678910111213141516171819202122232425262728293031323334353637383940public class Rental &#123; private Movie movie; private int daysRented; public Rental(Movie movie, int daysRented) &#123; this.movie = movie; this.daysRented = daysRented; &#125; public int getDaysRented() &#123; return daysRented; &#125; public Movie getMovie() &#123; return movie; &#125; double getCharge()&#123; double result = 0; switch (getMovie().getPriceCode()) &#123; case Movie.REGULAR: result += 2; if (getDaysRented() &gt; 2) &#123; result += (getDaysRented() - 2) * 1.5; &#125; break; case Movie.NEW_RELEASE: result += getDaysRented() * 3; break; case Movie.CHILEDRENS: result += 1.5; if (getDaysRented() &gt; 3) &#123; result += (getDaysRented() - 3) * 1.5; &#125; break; &#125; return result; &#125;&#125; 重构（四）提炼函数(越细小的函数功能越明确)/去除临时变量(使结构更清晰)1234567891011121314151617181920212223242526272829303132333435public String statement() &#123; Enumeration elements = rentals.elements(); StringBuilder result = new StringBuilder("Rental Record for " + getName() + "\n"); while (elements.hasMoreElements()) &#123; Rental each = (Rental) elements.nextElement(); //show figures for this rental result.append("\t").append(each.getMovie().getTitle()).append("\t").append(String.valueOf(each.getCharge())).append("\n"); &#125; //add footer lines result.append("Amount owed is ").append(String.valueOf(getTotalCharge())).append("\n"); result.append("You earned ").append(String.valueOf(getTotalFrequentRenterPoints())).append(" frequent renter points"); return result.toString(); &#125; private double getTotalCharge()&#123; double result = 0; Enumeration enumeration = rentals.elements(); while (enumeration.hasMoreElements())&#123; Rental each = (Rental) enumeration.nextElement(); result += each.getCharge(); &#125; return result; &#125; private int getTotalFrequentRenterPoints()&#123; int result = 0; Enumeration enumeration = rentals.elements(); while (enumeration.hasMoreElements())&#123; Rental each = (Rental) enumeration.nextElement(); result += each.getFrequentRenterPoints(); &#125; return result; &#125; Rental.java类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Rental &#123; private Movie movie; private int daysRented; public Rental(Movie movie, int daysRented) &#123; this.movie = movie; this.daysRented = daysRented; &#125; public int getDaysRented() &#123; return daysRented; &#125; public Movie getMovie() &#123; return movie; &#125; double getCharge()&#123; double result = 0; switch (getMovie().getPriceCode()) &#123; case Movie.REGULAR: result += 2; if (getDaysRented() &gt; 2) &#123; result += (getDaysRented() - 2) * 1.5; &#125; break; case Movie.NEW_RELEASE: result += getDaysRented() * 3; break; case Movie.CHILEDRENS: result += 1.5; if (getDaysRented() &gt; 3) &#123; result += (getDaysRented() - 3) * 1.5; &#125; break; &#125; return result; &#125; int getFrequentRenterPoints()&#123; if ((getMovie().getPriceCode() == Movie.NEW_RELEASE) &amp;&amp; getDaysRented() &gt; 1)&#123; return 2; &#125;else &#123; return 1; &#125; &#125;&#125; ###重构（五） 多态来提炼switch()语句 这里不直接抽象Movie类，是因为Movie类有自己的属性和生命周期。所以State模式的应用可以很好的解决这个问题。 Movie.java类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Movie &#123; public static final int CHILEDRENS = 2; public static final int REGULAR = 0; public static final int NEW_RELEASE = 1; public Movie(String title, int priceCode) &#123; this.title = title; setPriceCode(priceCode); &#125; public void setPriceCode(int arg) &#123; switch (arg) &#123; case REGULAR: price = new RegularPrice(); break; case CHILEDRENS: price = new ChildrensPrice(); break; case NEW_RELEASE: price = new NewReleasePrice(); break; default: throw new IllegalArgumentException("incorrect price code"); &#125; &#125; private String title; private Price price; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public Price getPrice() &#123; return price; &#125; public void setPrice(Price price) &#123; this.price = price; &#125; double getCharge(int daysRented) &#123; return price.getCharge(daysRented); &#125; int getFrequentRenterPoints(int daysRented) &#123; return price.getFrequentRenterPoints(daysRented); &#125;&#125; Price.java类12345678910111213141516171819202122232425262728293031323334abstract class Price &#123; abstract int getPriceCode(); double getCharge(int daysRented)&#123; double result = 0; switch (getPriceCode()) &#123; case Movie.REGULAR: result += 2; if (daysRented &gt; 2) &#123; result += (daysRented - 2) * 1.5; &#125; break; case Movie.NEW_RELEASE: result += daysRented * 3; break; case Movie.CHILEDRENS: result += 1.5; if (daysRented &gt; 3) &#123; result += (daysRented - 3) * 1.5; &#125; break; &#125; return result; &#125; int getFrequentRenterPoints(int daysRented) &#123; if ((getPriceCode() == Movie.NEW_RELEASE) &amp;&amp; daysRented &gt; 1) &#123; return 2; &#125; else &#123; return 1; &#125; &#125;&#125; NewReleasePrice.java类123456public class NewReleasePrice extends Price &#123; @Override int getPriceCode() &#123; return Movie.NEW_RELEASE; &#125;&#125; 其他两个实现类同NewReleasePrice类，就不列出来了。 ###重构（六） 继承12345678910abstract class Price &#123; abstract int getPriceCode(); abstract double getCharge(int daysRented); int getFrequentRenterPoints(int daysRented) &#123; return 1; &#125;&#125; NewReleasePrice.java类12345678910111213141516public class NewReleasePrice extends Price &#123; @Override int getPriceCode() &#123; return Movie.NEW_RELEASE; &#125; @Override double getCharge(int daysRented) &#123; return daysRented * 3; &#125; @Override int getFrequentRenterPoints(int daysRented) &#123; return (daysRented &gt; 1) ? 2 : 1; &#125;&#125; 前面列出的技术点仅仅只是一个起点，使你登堂入室之前的大门。如果没有这些技术，你根本无法对运行的程序进行任何设计上的改动。有了这些技术，你仍然做不到，但起码可以开始尝试了。]]></content>
  </entry>
</search>
